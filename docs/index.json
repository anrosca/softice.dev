[{"categories":["Concurrency control","Spring Framework"],"content":"Introduction Today we are going to learn about the difference between optimistic and pessimistic concurrency control using Spring-Data-Jpa. Concurrency control is about managing concurrent access to our data. Let’s say for example that we have a hotel booking system and there’s only one room available in the hotel and 2 users at the same time try to book it. Who will get the room? Well, it’s possible that both of them will succeed, but that will leave the hotel staff with an awkward situation. Concurrency control patterns help to deal with issues like this, either by preventing or detecting them. There are 2 flavours of concurrency control - pessimistic and optimistic locking. Pessimistic locking - prevents conflicts. We’re pessimistic and sure that conflicts will happen, therefore we block concurrent modifications by locking the data for exclusive access. Optimistic locking - detects conflicts. We’re optimistic that conflicts (or concurrent modifications) won’t happen, but if they do happen, we detect and deal with them, usually by issuing retries or returning an error response. Let’s take a closer look at both of these approaches in practice. ","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:1:0","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"Real-world example Let’s try to implement a doctor appointment system - a system where patients can create appointments to a doctor (for an annual physical for example). Here’s the domain model: @Entity @Table(name = \"doctors\") public class Doctor extends AbstractEntity { private String firstName; private String lastName; @Column(name = \"email_address\", nullable = false) private String email; @Enumerated(EnumType.STRING) private Specialty specialty; private String telephoneNumber; protected Doctor() { } //Getters, setters, builder, equals \u0026 hashcode were omitted for brevity } We have the Doctor JPA entity, having some simple fields identifying a particular doctor. Next, we’ll need a patient, which can look like this: @Entity @Table(name = \"patients\") public class Patient extends AbstractEntity { private String firstName; private String lastName; private String phoneNumber; private String source; private LocalDate birthDate; protected Patient() { } //Getters, setters, builder, equals \u0026 hashcode were omitted for brevity } Nothing fancy yet, another simple JPA entity representing a patient. Finally, let’s have a look at the Appointment entity, representing an appointment of a patient to a doctor which occurs at a specific date and time. @Entity @Table(name = \"appointments\") public class Appointment extends AbstractEntity { @ManyToOne(fetch = FetchType.LAZY, optional = false) private Doctor doctor; @ManyToOne(fetch = FetchType.LAZY, optional = false) private Patient patient; private LocalDate appointmentDate; private LocalTime startTime; private LocalTime endTime; private String operation; private String details; protected Appointment() { } //Getters, setters, builder, equals \u0026 hashcode were omitted for brevity } Now, let’s implement the REST endpoint for the appointment creation, it can look something like this: @RestController @RequestMapping(\"/api/v1/appointments\") public class AppointmentController { private final AppointmentFacade appointmentFacade; public AppointmentController(AppointmentFacade appointmentFacade) { this.appointmentFacade = appointmentFacade; } @PostMapping public ResponseEntity\u003c?\u003e create(@RequestBody @Validated(ValidationSequence.class) UpsertAppointmentRequest request) { AppointmentResponse createdAppointment = appointmentFacade.create(request); URI location = MvcUriComponentsBuilder.fromMethodCall(MvcUriComponentsBuilder.on(getClass()) .findById(createdAppointment.getId())) .build() .toUri(); return ResponseEntity.created(location) .build(); } } We have just a simple HTTP POST endpoint for creating a new appointment. The controller just delegates the request to the AppointmentFacade, which we’ll see briefly, and then it returns a response containing the Location header pointing to the newly created appointment. The request payload will look like this: POST http://localhost:8080/api/v1/appointments Content-Type: application/json { \"startDate\": \"2021-12-13T17:00\", \"endDate\": \"2021-12-13T18:00\", \"operation\": \"Annual physical\", \"doctorId\": \"f23e4567-e89b-12d3-a456-426614174000\", \"patientId\": \"f44e4567-ef9c-12d3-a45b-52661417400a\", \"details\": \"Just a regular annual physical\" } Moving on, let’s have a look at the AppointmentFacade. The purpose of it is to just convert the web-specific DTO - the UpsertAppointmentRequest into the domain model the service layer understands - the Appointment JPA entity. Also before returning the response, it converts the Appointment entity (which the service layer returned) to another web-specific DTO - the AppointmentResponse in this case. @Component public class AppointmentFacade { private final AppointmentService appointmentService; private final DoctorService doctorService; private final PatientService patientService; public AppointmentFacade(AppointmentService appointmentService, DoctorService doctorService, PatientService patientService) { this.appointmentService = appointmentService; this.doctorService = doctorService; this.patientService = patientService; } public Appointmen","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:2:0","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"Testing the solution Let’s try to write an integration test, which spins-up the whole application, executes a real HTTP request which will go through all the layers of the application (though the controller, facade, service, repository and back) and see if it works: @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class AppointmentControllerTest extends AbstractWebIntegrationTest { @Test public void shouldBeAbleToCreateAppointments() { String payload = \"\"\" { \"doctorId\": \"620e11c0-7d59-45be-85cc-0dc146532e78\", \"patientId\": \"f44e4567-ef9c-12d3-a45b-52661417400a\", \"startDate\": \"2022-05-23T16:00\", \"endDate\": \"2022-05-23T17:00\", \"operation\": \"Annual physical\", \"details\": \"New patient\" } \"\"\"; RequestEntity\u003cString\u003e request = makeRequestFor(\"/api/v1/appointments/\", HttpMethod.POST, payload); ResponseEntity\u003cString\u003e response = restTemplate.exchange(request, String.class); assertThat(response.getStatusCode().value()).isEqualTo(HttpStatus.CREATED.value()); assertThat(response.getHeaders().getLocation()).isNotNull(); } } If we try to run the test, it’ll pass with flying colors. But is it really working? Well, not really. We haven’t implemented any form of concurrency control in our application. We have the AppointmentRepository.findConflictingAppointment() method, but is it really working? Spoiler alert - it doesn’t. We have a race condition, the check-then-act sequence. When we want to insert a new appointment, we first check if we won’t create overlapping appointments (by calling the AppointmentRepository.findConflictingAppointment()), then if we didn’t spot an overlap, we insert the new appointment. That means that there’s a possibility that 2 different users at the same time will try to create an appointment to the same doctor, on the same day and time rage and both of them will succeed. Both of them checked for overlapping appointments at the same time. They didn’t find anything and proceeded with the insert. Now we have 2 appointments with the same time range which succeeded. The doctor wil definitely be confused. Let’s write a better test to try to simulate this issue. @Slf4j @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class AppointmentControllerTest extends AbstractWebIntegrationTest { private static final int NUMBER_OF_CONCURRENT_USERS = 5; private final CountDownLatch startLatch = new CountDownLatch(1); private final CountDownLatch requestLatch = new CountDownLatch(NUMBER_OF_CONCURRENT_USERS); private final ExecutorService requestPool = Executors.newFixedThreadPool(NUMBER_OF_CONCURRENT_USERS); @Test public void shouldBeAbleToCreateAppointments() { IntStream.rangeClosed(1, NUMBER_OF_CONCURRENT_USERS).forEach((item) -\u003e { requestPool.submit(() -\u003e { await(startLatch); log.info(\"Executing create appointment HTTP request\"); String payload = \"\"\" { \"doctorId\": \"620e11c0-7d59-45be-85cc-0dc146532e78\", \"patientId\": \"f44e4567-ef9c-12d3-a45b-52661417400a\", \"startDate\": \"2022-05-23T16:00\", \"endDate\": \"2022-05-23T17:00\", \"operation\": \"Annual physical\", \"details\": \"New patient\" } \"\"\"; RequestEntity\u003cString\u003e request = makeRequestFor(\"/api/v1/appointments/\", HttpMethod.POST, payload); ResponseEntity\u003cString\u003e response = restTemplate.exchange(request, String.class); log.info(\"Received HTTP status code: {}\", response.getStatusCode().value()); requestLatch.countDown(); }); }); startLatch.countDown(); await(requestLatch); RequestEntity\u003cAppointmentResponse[]\u003e allAppointmentsRequest = makeRequestFor(\"/api/v1/appointments/\", HttpMethod.GET); ResponseEntity\u003cAppointmentResponse[]\u003e allAppointmentsResponse = restTemplate.exchange(allAppointmentsRequest, AppointmentResponse[].class); assertThat(allAppointmentsResponse.getStatusCode().value()).isEqualTo(HttpStatus.OK.value()); log.info(\"All appointments: {}\", Arrays.toString(allAppointmentsResponse.getBody())); assertThat(allAppointmentsResponse.getBody().length).isEqualTo(1); } @AfterEach public void tearDown() throws InterruptedException {","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:3:0","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"Using pessimistic locking We’ve mentioned that pessimistic locking can help to prevent conflicts - concurrent data modifications. We can use this technique to try to fix our broken AppointmentService.create() method. When using pessimistic locking with Hibernate, a SQL Select for update is used under the hood. Select for update works by placing an exclusive lock on all of the rows returned, so that any other transaction will be blocked from accessing those rows (both for read and update). We can use this trick to obtain mutual exclusion for our AppointmentService.create() method. But what exactly should we lock? Since what we want to prevent is having 2 appointments for the same doctor at the same time, we can execute a Select for update on the doctor, something like this: selectid,first_name...fromdoctorsdwhered.id=\u003c\u003cdoctorIdforwhichweareaddinganappointment\u003e\u003eforupdate effectively gaining exclusive access to the doctor. From the moment the lock was obtained till the transaction will be committed, no other transaction will be able to read (or modify) the doctor. We can add a new method to our DoctorRepository for that: @Repository public interface DoctorRepository extends JpaRepository\u003cDoctor, String\u003e { @Lock(LockModeType.PESSIMISTIC_WRITE) @Query(\"select d from Doctor d where d.id = :id\") Doctor findByIdAndLock(@Param(\"id\") String id); } Notice the @Lock(LockModeType.PESSIMISTIC_WRITE) annotation - it’s the Spring-Data's way of telling that we want to use pessimistic locking for the method. Note There’s also @Lock(LockModeType.PESSIMISTIC_READ) which is translated to Select for share. With this type of lock multiple transactions can read the database table row at the same time, but “writer” transactions (executing updates) will be blocked. And vice versa, when an update is in progress, no “reader” transactions can obtain the shared lock. Now, we can try to use this method to obtain mutual-exclusion in our AppointmentService.create() method: @Service @Slf4j public class AppointmentService { private final AppointmentRepository appointmentRepository; private final DoctorRepository doctorRepository; public AppointmentService(AppointmentRepository appointmentRepository, DoctorRepository doctorRepository) { this.appointmentRepository = appointmentRepository; this.doctorRepository = doctorRepository; } @Transactional public Appointment create(Appointment appointmentToCreate) { checkForConflicts(appointmentToCreate); return appointmentRepository.save(appointmentToCreate); } private void checkForConflicts(Appointment appointmentToCreate) { LocalDate appointmentDate = appointmentToCreate.getAppointmentDate(); LocalTime startTime = appointmentToCreate.getStartTime(); LocalTime endTime = appointmentToCreate.getEndTime(); String doctorId = appointmentToCreate.getDoctor().getId(); Doctor doctor = doctorRepository.findByIdAndLock(doctorId); //here we obtain an exclusive lock for the doctor. From this point onward, //only the current transaction can continue and others will be blocked here //since they can't lock the doctor row Optional\u003cAppointment\u003e conflictingAppointment = appointmentRepository.findConflictingAppointment(doctorId, appointmentDate, startTime, endTime); conflictingAppointment.ifPresent(overlappingAppointment -\u003e { throw new ConflictingAppointmentsException(\"Doctor \" + doctor.getFirstName() + \" \" + doctor.getLastName() + \" has already an appointment, starting from \" + overlappingAppointment.getStartTime() + \" till \" + overlappingAppointment.getEndTime()); }); } } By adding the call to DoctorRepository.findByIdAndLock(doctorId), the first transaction to successfully execute this call will obtain the exclusive lock and therefore, the check-then-act sequence will be executed with mutual-exclusion, eliminating the race condition. Let’s run the test: The test passed, which is very nice. This solution has some drawbacks though. Since during appointment-creation we place an exclusive lock on the doctor, this means that no other transac","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:4:0","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"Optimistic locking Let’s look at another form of concurrency control - optimistic locking, which allows us to detect conflicts (or concurrent modifications). With this approach, we no longer lock anything and don’t prevent concurrent access, so the throughput (ideally) should not suffer. Instead we let all transactions do their work concurrently, and then at the end decide to commit or rollback them, depending upon whether concurrent modifications we’re spotted or not. In order to use optimistic locking, we’ll need to change our JPA entities and add a new field annotation with the @Version annotation, like shown below: @Entity @Table(name = \"doctors\") public class Doctor extends AbstractEntity { @Column(name = \"first_name\", nullable = false) private String firstName; @Column(name = \"last_name\", nullable = false) private String lastName; @Column(name = \"email_address\", nullable = false) private String email; private String telephoneNumber; @Enumerated(EnumType.STRING) private Specialty specialty; @Version private long version; //In order to use optimistic locking, we add this field } ","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:5:0","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"How it works Whenever you have a JPA entity which could be updated by concurrent transactions, most likely you should have optimistic locking in place. Without any locking mechanism, there is potential for silent data loss, a phenomenon known as lost updates. Let’s look at the lost update anomaly more closely. Let’s say that 2 transactions simultaneously try to update the doctor’s name: As we can see, all the work done by Transaction-2 was lost. Imagine that the above flow was something more serious, like booking the last available room in a hotel. We need a way to prevent that. Optimistic locking to the rescue! Now if we implement optimistic locking, the flow will look like this: What’s changed is that now the doctor table has a new column called version. Every time the doctor's database row is changed, Hibernate will increment that version and if during increment it will spot a version mismatch, it will throw a OptimisticLockException. In that case, the Transaction-1 should be re-executed since it was using stale data. The version field will be incremented by Hibernate every time the entity changes its state. Note Hibernate supports the following @Version field types: short or Short int or Integer long or Long java.sql.Timestamp Java 8 Date/Time such as java.time.Instant Using a numeric type which is large-enough (like Long) is the safest approach. Using time-based values, acting as “last modified time” is a bit more risky since theoretically it’s possible to have 2 threads using the same timestamp. Since our Doctor entity now has a @Version field, Hibernate will automatically prevent lost updates whenever the Doctor entity changes its state. But we have a completely different problem. We want to prevent appointments with overlapping time ranges, and during the creation of an appointment, the Doctor entity does not change its state. The idea is that we can force Hibernate to update the Doctor's version, thus preventing concurrent insertions of appointments. Let’s update our DoctorRepository.findByIdAndLock() method to make it use optimistic locking. For that we’ll add the @Lock(LockModeType.OPTIMISTIC_FORCE_INCREMENT) annotation. @Repository public interface DoctorRepository extends JpaRepository\u003cDoctor, String\u003e { @Lock(LockModeType.OPTIMISTIC_FORCE_INCREMENT) @Query(\"select d from Doctor d where d.id = :id\") Doctor findByIdAndLock(@Param(\"id\") String id); } Our AppointmentService didn’t suffer any changes, it still calls the DoctorRepository.findByIdAndLock() method, but this time using optimistic-locking (see below): @Service @Slf4j public class AppointmentService { private final AppointmentRepository appointmentRepository; private final DoctorRepository doctorRepository; public AppointmentService(AppointmentRepository appointmentRepository, DoctorRepository doctorRepository) { this.appointmentRepository = appointmentRepository; this.doctorRepository = doctorRepository; } @Transactional public Appointment create(Appointment appointmentToCreate) { checkForConflicts(appointmentToCreate); return appointmentRepository.save(appointmentToCreate); } private void checkForConflicts(Appointment appointmentToCreate) { LocalDate appointmentDate = appointmentToCreate.getAppointmentDate(); LocalTime startTime = appointmentToCreate.getStartTime(); LocalTime endTime = appointmentToCreate.getEndTime(); String doctorId = appointmentToCreate.getDoctor().getId(); Doctor doctor = doctorRepository.findByIdAndLock(doctorId); //here we use a LockModeType.OPTIMISTIC_FORCE_INCREMENT //which means that at flush-time, Hibernate will try //to detect if a concurrent modification happened and rollback the //transaction if so Optional\u003cAppointment\u003e conflictingAppointment = appointmentRepository.findConflictingAppointment(doctorId, appointmentDate, startTime, endTime); conflictingAppointment.ifPresent(overlappingAppointment -\u003e { throw new ConflictingAppointmentsException(\"Doctor \" + doctor.getFirstName() + \" \" + doctor.getLastName() + \" has already an appo","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:5:1","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"Pessimistic vs Optimistic locking At the first glance, we’ve achieved the same thing with both pessimistic and optimistic locking. What are the subtle differences? Let’s write a test to find out. We are going to try to create 3 appointments at the same time, for the same doctor, something like this: Appointment A with start time 2022-05-23T16:00 and end time 2022-05-23T17:00 Appointment B with start time 2022-05-23T16:00 and end time 2022-05-23T17:00 (the same as above) Appointment C with start time 2022-05-23T11:00 and end time 2022-05-23T14:00 Appointment A and B have overlapping times, so only one of them should succeed (depending on which one will be first). Appointment C does not create any overlaps, so it should succeed in our case. Thus, we expect that only 2 appointments should be created. Either A and C or B and C. Now let’s write our test, which will be a bit complicated. We’ll be using pessimistic locking first. Let’s update the DoctorRepository to use pessimistic locking: @Repository public interface DoctorRepository extends JpaRepository\u003cDoctor, String\u003e { @Lock(LockModeType.PESSIMISTIC_WRITE) @Query(\"select d from Doctor d where d.id = :id\") Doctor findByIdAndLock(@Param(\"id\") String id); } The test will look like this: @Slf4j @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) public class PessimisticVsOptimisticAppointmentControllerTest extends AbstractWebIntegrationTest { private static final int NUMBER_OF_CONCURRENT_USERS = 3; private final CountDownLatch startLatch = new CountDownLatch(1); private final CountDownLatch requestLatch = new CountDownLatch(NUMBER_OF_CONCURRENT_USERS); private final ExecutorService requestPool = Executors.newFixedThreadPool(NUMBER_OF_CONCURRENT_USERS); @Test public void shouldBeAbleToCreateTwoAppointments() { IntStream.rangeClosed(1, 2).forEach((item) -\u003e { //Execute simultaneously 2 overlapping appointments: A and B requestPool.submit(() -\u003e { await(startLatch); log.info(\"Executing create appointment HTTP request\"); String payload = \"\"\" { \"doctorId\": \"620e11c0-7d59-45be-85cc-0dc146532e78\", \"patientId\": \"f44e4567-ef9c-12d3-a45b-52661417400a\", \"startDate\": \"2022-05-23T16:00\", \"endDate\": \"2022-05-23T17:00\", \"operation\": \"Annual physical\", \"details\": \"New patient\" } \"\"\"; RequestEntity\u003cString\u003e request = makeRequestFor(\"/api/v1/appointments/\", HttpMethod.POST, payload); ResponseEntity\u003cString\u003e response = restTemplate.exchange(request, String.class); log.info(\"Received HTTP status code: {}\", response.getStatusCode().value()); requestLatch.countDown(); }); }); requestPool.submit(() -\u003e { //Execute appointment C, which doesn't have any overlaps await(startLatch); log.info(\"Executing create appointment HTTP request\"); String payload = \"\"\" { \"doctorId\": \"620e11c0-7d59-45be-85cc-0dc146532e78\", \"patientId\": \"f44e4567-ef9c-12d3-a45b-52661417400a\", \"startDate\": \"2022-05-23T11:00\", \"endDate\": \"2022-05-23T14:00\", \"operation\": \"Annual physical\", \"details\": \"New patient\" } \"\"\"; RequestEntity\u003cString\u003e request = makeRequestFor(\"/api/v1/appointments/\", HttpMethod.POST, payload); ResponseEntity\u003cString\u003e response = restTemplate.exchange(request, String.class); log.info(\"Received HTTP status code: {}\", response.getStatusCode().value()); requestLatch.countDown(); }); startLatch.countDown(); await(requestLatch); RequestEntity\u003cAppointmentResponse[]\u003e allAppointmentsRequest = makeRequestFor(\"/api/v1/appointments/\", HttpMethod.GET); ResponseEntity\u003cAppointmentResponse[]\u003e allAppointmentsResponse = restTemplate.exchange(allAppointmentsRequest, AppointmentResponse[].class); assertThat(allAppointmentsResponse.getStatusCode().value()).isEqualTo(HttpStatus.OK.value()); log.info(\"All appointments: {}\", Arrays.toString(allAppointmentsResponse.getBody())); assertThat(allAppointmentsResponse.getBody()).contains(makeExpectedAppointments()); //We expect 2 appointments to be created } private AppointmentResponse[] makeExpectedAppointments() { return new AppointmentResponse[]{ AppointmentResponse.builder() .","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:6:0","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"Implementing retries on the server-side with Spring Retry In order to implement retries on the server side, we can use Spring Retry. For that, we’ll add the following Maven dependency: \u003cdependency\u003e \u003cgroupId\u003eorg.springframework.retry\u003c/groupId\u003e \u003cartifactId\u003espring-retry\u003c/artifactId\u003e \u003cversion\u003e1.3.3\u003c/version\u003e \u003c/dependency\u003e After that, we’ll need to add a small piece of Java configuration, to enable the retries, like this: @Configuration(proxyBeanMethods = false) @EnableRetry public class RetryConfig { } Almost done. Now we can use the @Retryable annotation to specify what method should be re-executed in case of optimistic lock failures. Spring-Data-Jpa will throw the ObjectOptimisticLockingFailureException whenever we have concurrent modifications of a versioned JPA entity. A good candidate for retries it the AppointmentFacade.create() method (which is shown below), since it is the one starting the transaction: @Component public class AppointmentFacade { //... @Retryable(ObjectOptimisticLockingFailureException.class) //Retry 3 times in case of ObjectOptimisticLockingFailureException public AppointmentResponse create(UpsertAppointmentRequest request) { Appointment appointmentToCreate = toAppointment(request); Appointment createdAppointment = appointmentService.create(appointmentToCreate); return AppointmentResponse.from(createdAppointment); } //... } Let’s re-run our test to see if using retries helped: Looking good, the test passed. The gist is that whenever we have optimistic locking in place, sometimes we should also implement server-side retries. ","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:6:1","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"Using synchronized keyword Since our application can’t perform well under concurrent requests, one attempt to solve the issue could be to prevent concurrent executions of the AppointmentService.create() method (since it’s the one having the race-condition with the check-then-act sequence). We can obtain mutual-exclusion for the save method by adding the synchronized keyword. Will it solve the issue? Well, almost. Let’s try it out: @Service @Slf4j public class AppointmentService { private final AppointmentRepository appointmentRepository; private final DoctorRepository doctorRepository; public AppointmentService(AppointmentRepository appointmentRepository, DoctorRepository doctorRepository) { this.appointmentRepository = appointmentRepository; this.doctorRepository = doctorRepository; } @Transactional public synchronized Appointment create(Appointment appointmentToCreate) { //synchronized keyword was added checkForConflicts(appointmentToCreate); return appointmentRepository.save(appointmentToCreate); } } The test still fails. Very strange isn’t it. Here’s the explanation: Explanation Since the AppointmentService class has @Transactional methods, Spring will create a proxy for the AppointmentService. The original AppointmentService.create() method is synchronized, but the same method from the proxy isn’t. Also, the proxy is the one performing the EntityManager flush before the commit. That effectively means that at the time we’ve exited the synchronized method, the SQL inserts were not executed yet. That leaves time for another thread to grab the lock and start executing the create() method. This means that the second thread might not see the previously inserted appointment so it will come to the conclusion that no overlapp is present and insert successfully the conflicting appointment. What we need to do is to ensure that lock is released only after the proxy flushed the persistence context and committed the transaction. We can achieve this by placing a synchronized block in the facade, like this: @Component public class AppointmentFacade { private final AppointmentService appointmentService; private final DoctorService doctorService; private final PatientService patientService; public AppointmentFacade(AppointmentService appointmentService, DoctorService doctorService, PatientService patientService) { this.appointmentService = appointmentService; this.doctorService = doctorService; this.patientService = patientService; } public AppointmentResponse create(UpsertAppointmentRequest request) { Appointment appointmentToCreate = toAppointment(request); Appointment createdAppointment = null; synchronized (this) { //We need to add the synchronized block here createdAppointment = appointmentService.create(appointmentToCreate); } return AppointmentResponse.from(createdAppointment); } private Appointment toAppointment(final UpsertAppointmentRequest request) { //... } } Let’s try it out: It appears to be working at the first glance, but it’s the worst solution (it can hardly can be called a solution). This solution will limit our ability to scale the application not only because the throughput will be reduced significantly but also we are unable to run another instance of our application. If we run the second instance of our application, we’ll have another JVM with a brand-new heap so we lose mutual exclusion. With the synchronized keyword we obtain mutual-exclusion per JVM so a second JVM will bring back our problem with the race condition. ","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:7:0","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"Using ShedLock Instead of using the synchronized keyword, we can use a library like ShedLock. Though this library was designed for preventing @Scheduled methods executing concurrently when we start multiple instances of our application, we can safely use it as a distributed lock as well. We’ll need to add the following Maven dependencies: \u003cdependencies\u003e \u003cdependency\u003e \u003cgroupId\u003enet.javacrumbs.shedlock\u003c/groupId\u003e \u003cartifactId\u003eshedlock-spring\u003c/artifactId\u003e \u003cversion\u003e${shedlock.version}\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003enet.javacrumbs.shedlock\u003c/groupId\u003e \u003cartifactId\u003eshedlock-provider-jdbc-template\u003c/artifactId\u003e \u003cversion\u003e${shedlock.version}\u003c/version\u003e \u003c/dependency\u003e \u003c/dependencies\u003e After that we’ll add the following Java configuration, where we specify the DataSource (since the lock metadata is sored in the database) and we also configure 2 parameters: database table name which holds the locks and the default lock timeout, like this: @Configuration(proxyBeanMethods = false) @EnableSchedulerLock(defaultLockAtMostFor = \"${shedlock.default-lock-at-most-for:10s}\") public class ShedLockConfig { @Bean public LockProvider lockProvider(DataSource dataSource, @Value(\"${shedlock.lock-table-name:shedlock}\") String lockTableName) { return new JdbcTemplateLockProvider(JdbcTemplateLockProvider.Configuration.builder() .withJdbcTemplate(new JdbcTemplate(dataSource)) .withTableName(lockTableName) .usingDbTime() .build()); } } We also need to add a new Flyway migration, which looks like this: createtableshedlock(namevarchar(64)notnull,lock_untiltimestampnotnull,locked_attimestampnotnull,locked_byvarchar(255)notnull,primarykey(name)); Almost ready. Now we can annotate the method for which we want to obtain mutual-exclusion across multiple application instances with the @SchedulerLock annotation, (see below): @Service @Slf4j public class AppointmentService { private static final String CREATE_APPOINTMENT_LOCK_NAME = \"createAppointmentLock\"; private final AppointmentRepository appointmentRepository; public AppointmentService(AppointmentRepository appointmentRepository) { this.appointmentRepository = appointmentRepository; } @Transactional @SchedulerLock(name = CREATE_APPOINTMENT_LOCK_NAME) public Appointment create(Appointment appointmentToCreate) { checkForConflicts(appointmentToCreate); return appointmentRepository.save(appointmentToCreate); } private void checkForConflicts(Appointment appointmentToCreate) { LocalDate appointmentDate = appointmentToCreate.getAppointmentDate(); LocalTime startTime = appointmentToCreate.getStartTime(); LocalTime endTime = appointmentToCreate.getEndTime(); String doctorId = appointmentToCreate.getDoctor().getId(); Doctor doctor = appointmentToCreate.getDoctor(); Optional\u003cAppointment\u003e conflictingAppointment = appointmentRepository.findConflictingAppointment(doctorId, appointmentDate, startTime, endTime); conflictingAppointment.ifPresent(overlappingAppointment -\u003e { throw new ConflictingAppointmentsException(\"Doctor \" + doctor.getFirstName() + \" \" + doctor.getLastName() + \" has already an appointment, starting from \" + overlappingAppointment.getStartTime() + \" till \" + overlappingAppointment.getEndTime()); }); } } That’s it. Now we can start multiple instances of our application and still have the desired behavior - no overlapping appointments. The downside being that we’ve added a new dependency. Let’s run the test: And it passes as well. ","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:8:0","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Concurrency control","Spring Framework"],"content":"Conclusion In this blog post we’ve looked at 2 forms of concurrency control - optimistic and pessimistic locking. We looked at a real-world example where we actually need a form of concurrency control and explored various ways to fix the problem, like using pessimistic locking (which is backed by select for update), optimistic locking which uses version checks. We saw that when using optimistic locking, sometimes server-side retries are needed. We’ve also looked at the synchronized keyword and saw that it’s applicable only for the cases where we have only one instance of our application and don’t plan to add new ones. And finally, the last solution we explored was using the ShedLock library, which basically is a distributed lock. The code can be found on GitHub. ","date":"2022-05-19","objectID":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/:9:0","tags":["Spring Framework","Concurrency control","Pessimistic locking","Optimistic locking"],"title":"Optimistic and pessimistic concurrency control with Spring-Data-JPA","uri":"/posts/optimistic_and_pessimistic_locking_with_spring_data_jpa/"},{"categories":["Spring Framework"],"content":"Introduction Today we’re going to take a look at a new Spring @Transactional puzzler involving the @TransactionalEventListener. It’s an old quirk of Spring related to transaction-bound events (both declarative and programmatic ones) and though not commonly experienced, encountering it can leave you confused for hours. Let’s have a look. ","date":"2022-05-16","objectID":"/posts/spring_puzzler_transactional_event_listener/:1:0","tags":["Spring Framework","Declarative transaction management","@TransactionalEventListener"],"title":"Spring puzzler: the @TransactionalEventListener","uri":"/posts/spring_puzzler_transactional_event_listener/"},{"categories":["Spring Framework"],"content":"The puzzler Suppose we have the following code: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { Movie movie = Movie.builder() .name(\"Joker\") .build(); movieService.save(movie); }; } } @Service @Slf4j class MovieService { private final MovieRepository movieRepository; public MovieService(MovieRepository movieRepository) { this.movieRepository = movieRepository; } @Transactional public Movie save(Movie movie) { Movie savedMovie = movieRepository.save(movie); log.debug(\"Saved movie: {}\", savedMovie); return savedMovie; } } Nothing fancy so far. We have a CommandLineRunner which calls the MovieService.save() method which saves to the database a Movie JPA entity using Spring-Data-JPA. The Movie entity looks like this btw: @Entity @Table(name = \"movies\") public class Movie extends AbstractEntity { private String name; //Getters, setters, toString and the builder are omitted for brevity Now let’s say we want to implement some form of auditing. Every time a Movie entity is saved, we want to save also a MovieAudit entity, just for inspection purposes. The MovieAudit entity looks like this: @Entity @Table(name = \"movie_audit\") public class MovieAudit extends AbstractEntity { private String name; private String movieId; public static MovieAudit from(Movie movie) { return MovieAudit.builder() .movieId(movie.getId()) .name(movie.getName()) .build(); } //Getters, setters, toString and the builder are omitted for brevity Now in order to implement the required behavior, we can inject the repository for the MovieAudit entity directly into our MovieService and save our MovieAudit along with the Movie entity in the same transaction, like this: @Service @Slf4j class MovieService { private final MovieRepository movieRepository; private final MovieAuditRepository movieAuditRepository; public MovieService(MovieRepository movieRepository, MovieAuditRepository movieAuditRepository) { this.movieRepository = movieRepository; this.movieAuditRepository = movieAuditRepository; } @Transactional public Movie save(Movie movie) { Movie savedMovie = movieRepository.save(movie); log.debug(\"Saved movie: {}\", savedMovie); movieAuditRepository.save(MovieAudit.from(savedMovie)); return savedMovie; } } This approach doesn’t look that good since our MovieService looks a bit messier. Let’s try to move MovieAudit logic our of the MovieService. But how? Spring events to the rescue! ","date":"2022-05-16","objectID":"/posts/spring_puzzler_transactional_event_listener/:2:0","tags":["Spring Framework","Declarative transaction management","@TransactionalEventListener"],"title":"Spring puzzler: the @TransactionalEventListener","uri":"/posts/spring_puzzler_transactional_event_listener/"},{"categories":["Spring Framework"],"content":"Using Spring events Instead of saving the MovieAudit from the MovieService, we can adjust the MovieService to publish a Spring event. Just like this: @Service @Slf4j class MovieService { private final MovieRepository movieRepository; private final ApplicationEventPublisher eventPublisher; public MovieService(MovieRepository movieRepository, ApplicationEventPublisher eventPublisher) { this.movieRepository = movieRepository; this.eventPublisher = eventPublisher; } @Transactional public Movie save(Movie movie) { Movie savedMovie = movieRepository.save(movie); log.debug(\"Saved movie: {}\", savedMovie); eventPublisher.publishEvent(new MovieSavedEvent(savedMovie)); return savedMovie; } } On one hand, our MovieService didn’t become simpler but this approach is more flexible since we can plug-in as many event listeners as we want. For example if in the future we’ll be required to do some other action every time a Movie entity is saved, we can just add a new event-listener. Our event-listener which persists the MovieAudit can look like this: @Slf4j @Component class MovieAuditEventListener { private final MovieAuditRepository movieAuditRepository; public MovieAuditEventListener(MovieAuditRepository movieAuditRepository) { this.movieAuditRepository = movieAuditRepository; } @EventListener(MovieSavedEvent.class) @Transactional public void on(MovieSavedEvent event) { log.debug(\"Received event: {}\", event); MovieAudit movieAudit = MovieAudit.from(event.getMovie()); movieAuditRepository.save(movieAudit); log.debug(\"Saved movie audit: {}\", movieAudit); } } Let’s run the example and check the logs: 2022-05-16 23:51:14.100 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-16 23:51:14.100 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1483155688\u003copen\u003e)] for JPA transaction 2022-05-16 23:51:14.102 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@f4f843f] 2022-05-16 23:51:14.106 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1483155688\u003copen\u003e)] for JPA transaction 2022-05-16 23:51:14.106 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-16 23:51:14.114 DEBUG 1641040 --- [main] i.e.spring.tx.management.MovieService: Saved movie: Movie{name='Joker', id='e4d96c77-fbe4-4407-af35-e11176a79da5'} 2022-05-16 23:51:14.115 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1483155688\u003copen\u003e)] for JPA transaction 2022-05-16 23:51:14.115 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-16 23:51:14.117 DEBUG 1641040 --- [main] i.e.s.t.m.MovieAuditEventListener : Received event: MovieSavedEvent{movie=Movie{name='Joker', id='e4d96c77-fbe4-4407-af35-e11176a79da5'}} 2022-05-16 23:51:14.117 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1483155688\u003copen\u003e)] for JPA transaction 2022-05-16 23:51:14.117 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-16 23:51:14.118 DEBUG 1641040 --- [main] i.e.s.t.m.MovieAuditEventListener : Saved movie audit: MovieAudit{name='Joker', id='b73e3f40-7cad-4821-91ca-c867bd1e79da', movieId='e4d96c77-fbe4-4407-af35-e11176a79da5'} 2022-05-16 23:51:14.119 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-16 23:51:14.119 DEBUG 1641040 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(1483155688\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into movie_a","date":"2022-05-16","objectID":"/posts/spring_puzzler_transactional_event_listener/:3:0","tags":["Spring Framework","Declarative transaction management","@TransactionalEventListener"],"title":"Spring puzzler: the @TransactionalEventListener","uri":"/posts/spring_puzzler_transactional_event_listener/"},{"categories":["Spring Framework"],"content":"The @TransactionalEventListener annotation A @TransactionalEventListener is a similar to a regular @EventListener, the difference being that the events are transaction-bounded. This means that the event listeners in this case are not immediately-invoked, but are called when the transaction from which they were thrown changes its phase. Here are the possible phases: @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT): the default. The listeners are invoked after the transaction commit has completed successfully. @TransactionalEventListener(phase = TransactionPhase.AFTER_ROLLBACK):the listeners are invoked after the transaction has been rolled-back. @TransactionalEventListener(phase = TransactionPhase.BEFORE_COMMIT): the listeners are invoked before the transaction will be committed. @TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION): the listeners are invoked after the transaction will be completed, so both after commit and rollback. In our example we’ll use @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) since we want our MovieAudit entity saved after the transaction of the MovieService.save() method will be committed. Our listener will look something like this: @Slf4j @Component class MovieAuditEventListener { private final MovieAuditRepository movieAuditRepository; public MovieAuditEventListener(MovieAuditRepository movieAuditRepository) { this.movieAuditRepository = movieAuditRepository; } @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) @Transactional public void on(MovieSavedEvent event) { log.debug(\"Received event: {}\", event); MovieAudit movieAudit = MovieAudit.from(event.getMovie()); movieAuditRepository.save(movieAudit); log.debug(\"Saved movie audit: {}\", movieAudit); } } Now let’s check the logs: 2022-05-16 23:53:07.427 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-16 23:53:07.427 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1305564302\u003copen\u003e)] for JPA transaction 2022-05-16 23:53:07.428 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@3b362f1] 2022-05-16 23:53:07.432 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1305564302\u003copen\u003e)] for JPA transaction 2022-05-16 23:53:07.432 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-16 23:53:07.442 DEBUG 1641223 --- [main] i.e.spring.tx.management.MovieService: Saved movie: Movie{name='Joker', id='dc766b33-2ba7-4989-bea2-99734243f0c9'} 2022-05-16 23:53:07.443 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-16 23:53:07.443 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(1305564302\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-16 23:53:07.454 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1305564302\u003copen\u003e)] for JPA transaction 2022-05-16 23:53:07.454 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-16 23:53:07.456 DEBUG 1641223 --- [main] i.e.s.t.m.MovieAuditEventListener : Received event: MovieSavedEvent{movie=Movie{name='Joker', id='dc766b33-2ba7-4989-bea2-99734243f0c9'}} 2022-05-16 23:53:07.457 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1305564302\u003copen\u003e)] for JPA transaction 2022-05-16 23:53:07.457 DEBUG 1641223 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-16 23:53:07.458 DEBUG 1641223 --- [main] i","date":"2022-05-16","objectID":"/posts/spring_puzzler_transactional_event_listener/:4:0","tags":["Spring Framework","Declarative transaction management","@TransactionalEventListener"],"title":"Spring puzzler: the @TransactionalEventListener","uri":"/posts/spring_puzzler_transactional_event_listener/"},{"categories":["Spring Framework"],"content":"Explanation The short version is that the MovieService has created a transaction and has bound it to the current thread. Then the MovieService's proxy commits the transaction and invokes the @TransactionalEventListener. The thing is that at this point, the initial transaction is already committed but it wasn’t yet cleaned-up (or unbound from the current thread). Because of that, when the MovieAuditEventListener is called, it thinks that there’s an existing transaction and it tries to join it. The listener thinks that there’s an existing transaction because it can find the thread-local data of the previously committed transaction. This way Spring is fooled and it joins a committed transaction. Now, the SQL insert for the MovieAudit was lost since Hibernate usually executes inserts at flush-time (which happens at the transaction commit), but since the transaction was committed a long time ago, nothing happens. We can’t commit a transaction twice. In-depth explanation The TransactionSynchronizationManager class is the place where all of the thread-bounded transaction data is stored, like this: package org.springframework.transaction.support; public abstract class TransactionSynchronizationManager { private static final ThreadLocal\u003cMap\u003cObject, Object\u003e\u003e resources = new NamedThreadLocal\u003c\u003e(\"Transactional resources\"); private static final ThreadLocal\u003cSet\u003cTransactionSynchronization\u003e\u003e synchronizations = new NamedThreadLocal\u003c\u003e(\"Transaction synchronizations\"); private static final ThreadLocal\u003cString\u003e currentTransactionName = new NamedThreadLocal\u003c\u003e(\"Current transaction name\"); private static final ThreadLocal\u003cBoolean\u003e currentTransactionReadOnly = new NamedThreadLocal\u003c\u003e(\"Current transaction read-only status\"); private static final ThreadLocal\u003cInteger\u003e currentTransactionIsolationLevel = new NamedThreadLocal\u003c\u003e(\"Current transaction isolation level\"); private static final ThreadLocal\u003cBoolean\u003e actualTransactionActive = new NamedThreadLocal\u003c\u003e(\"Actual transaction active\"); //... When the PlatformTransactionManager (in our case it’s the JpaTransactionManager) needs to see if there’s an active transaction, it checks the TransactionSynchronizationManager to see if we have any thread-bounded resources, like this: package org.springframework.orm.jpa; public class JpaTransactionManager extends AbstractPlatformTransactionManager implements ResourceTransactionManager, BeanFactoryAware, InitializingBean { //... @Override protected Object doGetTransaction() { JpaTransactionObject txObject = new JpaTransactionObject(); txObject.setSavepointAllowed(isNestedTransactionAllowed()); EntityManagerHolder emHolder = (EntityManagerHolder) TransactionSynchronizationManager.getResource(obtainEntityManagerFactory()); //Do we have already an EntityManger? if (emHolder != null) { if (logger.isDebugEnabled()) { logger.debug(\"Found thread-bound EntityManager [\" + emHolder.getEntityManager() + \"] for JPA transaction\"); } txObject.setEntityManagerHolder(emHolder, false); //If found an existing EntityManager, set it on the new transaction object } if (getDataSource() != null) { ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.getResource(getDataSource()); //Find the JDBC Connection holder txObject.setConnectionHolder(conHolder); //Set it on the new transaction object } return txObject; } At this point, nothing fancy happened. We’ve just collected the data about the existing transaction (if any). Spring has instantiated a JpaTransactionObject instance and has populated it with the thread-bound EntityManagerHolder (which has an EntityManager) and a ConnectionHolder (which has a JDBC Connection). But these 2 values can have the value of null if there isn’t an existing transaction. Now Spring checks if we do have an active transaction, like this: package org.springframework.transaction.support; public abstract class AbstractPlatformTransactionManager implements PlatformTransactionManager, Serializable { //... @Override public final TransactionStatu","date":"2022-05-16","objectID":"/posts/spring_puzzler_transactional_event_listener/:5:0","tags":["Spring Framework","Declarative transaction management","@TransactionalEventListener"],"title":"Spring puzzler: the @TransactionalEventListener","uri":"/posts/spring_puzzler_transactional_event_listener/"},{"categories":["Spring Framework"],"content":"How to fix it? In order to fix it, we’ll need to change the propagation level for the MovieAuditEventListener and use propagation = Propagation.REQUIRES_NEW so that we force it to create a new transaction, like this: @Slf4j @Component class MovieAuditEventListener { private final MovieAuditRepository movieAuditRepository; public MovieAuditEventListener(MovieAuditRepository movieAuditRepository) { this.movieAuditRepository = movieAuditRepository; } @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT) @Transactional(propagation = Propagation.REQUIRES_NEW) public void on(MovieSavedEvent event) { log.debug(\"Received event: {}\", event); MovieAudit movieAudit = MovieAudit.from(event.getMovie()); movieAuditRepository.save(movieAudit); log.debug(\"Saved movie audit: {}\", movieAudit); } } Let’s run it and check the logs to see if it actually works: 2022-05-17 09:05:21.798 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-17 09:05:21.799 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1187406578\u003copen\u003e)] for JPA transaction 2022-05-17 09:05:21.800 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@18b40fe6] 2022-05-17 09:05:21.804 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1187406578\u003copen\u003e)] for JPA transaction 2022-05-17 09:05:21.804 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-17 09:05:21.812 DEBUG 1666084 --- [main] i.e.spring.tx.management.MovieService: Saved movie: Movie{name='Joker', id='c2322370-471e-4512-96a5-d04941ecff4f'} 2022-05-17 09:05:21.813 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-17 09:05:21.813 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(1187406578\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-17 09:05:21.824 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1187406578\u003copen\u003e)] for JPA transaction 2022-05-17 09:05:21.824 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Suspending current transaction, creating new transaction with name [inc.evil.spring.tx.management.MovieAuditEventListener.on] 2022-05-17 09:05:21.824 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(2117195067\u003copen\u003e)] for JPA transaction 2022-05-17 09:05:21.825 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@68d8eb4f] 2022-05-17 09:05:21.828 DEBUG 1666084 --- [main] i.e.s.t.m.MovieAuditEventListener : Received event: MovieSavedEvent{movie=Movie{name='Joker', id='c2322370-471e-4512-96a5-d04941ecff4f'}} 2022-05-17 09:05:21.828 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(2117195067\u003copen\u003e)] for JPA transaction 2022-05-17 09:05:21.828 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-17 09:05:21.829 DEBUG 1666084 --- [main] i.e.s.t.m.MovieAuditEventListener : Saved movie audit: MovieAudit{name='Joker', id='5125bd9f-e854-496d-822f-d3a441c02f22', movieId='c2322370-471e-4512-96a5-d04941ecff4f'} 2022-05-17 09:05:21.830 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-17 09:05:21.830 DEBUG 1666084 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(2117195067\u003copen\u003e)] Hibernate: insert into movie_audit (","date":"2022-05-16","objectID":"/posts/spring_puzzler_transactional_event_listener/:6:0","tags":["Spring Framework","Declarative transaction management","@TransactionalEventListener"],"title":"Spring puzzler: the @TransactionalEventListener","uri":"/posts/spring_puzzler_transactional_event_listener/"},{"categories":["Spring Framework"],"content":"Conclusion In this blog post we’ve looked at an odd quirk of Spring regarding the @TransactionalEventListener and we saw that these listeners have to use @Transactional(propagation = Propagation.REQUIRES_NEW) if they want to use transactions, otherwise it won’t work and they will join a dead, committed transaction and this will make them lose all of their work related to the database. We also saw that the programmatic approach - using the TransactionSynchronizationManager.registerSynchronization() does not help. See you later, in another blog post. The code is available on GitHub. ","date":"2022-05-16","objectID":"/posts/spring_puzzler_transactional_event_listener/:7:0","tags":["Spring Framework","Declarative transaction management","@TransactionalEventListener"],"title":"Spring puzzler: the @TransactionalEventListener","uri":"/posts/spring_puzzler_transactional_event_listener/"},{"categories":["Spring Framework"],"content":"Introduction Today we’ll be looking at a Spring puzzler - transactional @PostContruct methods. Though it’s not a commonly used thing, it can be useful to know some limitations of the Spring’s declarative transaction management approach. ","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:1:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"@PostConstruct methods The @PostConstruct are called automatically by Spring after all of the bean’s dependencies were injected. Let’s look at an example: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } } @Service @Slf4j class MovieService { @Autowired private EntityManager entityManager; public MovieService() { log.debug(\"entityManager: {}\", entityManager); } @PostConstruct public void init() { log.debug(\"entityManager: {}\", entityManager); } } We have a MovieService which is a Spring bean, and it used field-injection to get a dependency - the EntityManager. The question is, when is our spring bean fully-initialized and ready to be used? Usually we consider that after calling the constructor, the instantiated object is in the right state so it can be safely used. Let’s look at the logs to see if that’s the case: 2022-05-15 16:49:36.432 DEBUG 1451865 --- [main] i.e.spring.tx.management.MovieService: entityManager: null 2022-05-15 16:49:36.447 DEBUG 1451865 --- [main] i.e.spring.tx.management.MovieService: entityManager: Shared EntityManager proxy for target factory [org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean@79ab97fd] As we can see from the logs, when the MovieService constructor is executing, the entityManager field still has the value of null. The @PostConstruct methods come to the rescue. They’re invoked after all of the bean’s dependencies were set, no matter the injection type used: constructor, field or setter. Our logs prove that that’s the case, the field entityManager is no longer null when the @PostConstruct method was called. Tip It’s considered a best practice to use constructor injection and steer clear of field injection since field-injection makes unit-testing way harder than it needs to be and it also prevents us from having immutable beans. ","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:2:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"The puzzler What will happen if we’ll slightly modify our previous example and try to persist a JPA entity? Here are the options: The movie entity will be successfully persisted to the database The init method won’t be called BeanCreationException will be thrown TransactionRequiredException will be thrown Take a wild guess :) @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } } @Service @Slf4j class MovieService { @Autowired private EntityManager entityManager; public MovieService() { log.debug(\"entityManager: {}\", entityManager); } @PostConstruct @Transactional public void init() { log.debug(\"entityManager: {}\", entityManager); Movie movie = Movie.builder() .name(\"Joker\") .build(); entityManager.persist(movie); } } Answer The right answer is: The movie entity will be successfully persisted to the database The init method won’t be called BeanCreationException will be thrown TransactionRequiredException will be thrown Actually an exception will be thrown, specifically BeanCreationException with a cause of TransactionRequiredException. The BeanCreationException exception is thrown when a @PostConstruct method throws an exception. Here are the logs: org.springframework.beans.factory.BeanCreationException: Error creating bean with name 'movieService': Invocation of init method failed; nested exception is javax.persistence.TransactionRequiredException: No EntityManager with actual transaction available for current thread - cannot reliably process 'persist' call at org.springframework.beans.factory.annotation.InitDestroyAnnotationBeanPostProcessor.postProcessBeforeInitialization(InitDestroyAnnotationBeanPostProcessor.java:160) ~[spring-beans-5.3.19.jar:5.3.19] It’s worth stating that we deliberately used directly the EntityManager, since it doesn’t create any transactions but its persist method expects to be called with an active transaction. Using Spring-data-jpa here will help, since Spring-data-jpa creates transactions as a last-resort, so using Spring-data-jpa will fix the puzzler. ","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:3:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"Explanation But what really happened? In one of our previous blog posts we mentioned that Spring’s declarative transaction management approach (using the @Transactional annotation) is based-on proxies by default. Here’s a little refresher on how a proxy looks like: Well, it turns out that at the time when the @PostConstruct method is invoked, the proxy for our MovieService was not created yet, so we can’t use the @Transactional annotation since there’s no proxy to intercept the init method call and create a transaction for us. Very unfortunate, isn’t it? ","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:3:1","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"How to fix it? There are a couple of ways to fix this problem, let’s explore the one by one. ","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:4:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"Using programmatic transaction management Well, if during the @PostConstruct method call the proxy is not ready, one option would be to get rid of declarative transaction management and use the programmatic one, since it doesn’t rely on proxies, like this: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } } @Service @Slf4j class MovieService { @Autowired private EntityManager entityManager; private final PlatformTransactionManager transactionManager; public MovieService(PlatformTransactionManager transactionManager) { this.transactionManager = transactionManager; log.debug(\"entityManager: {}\", entityManager); } @PostConstruct public void init() { TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager); transactionTemplate.execute(new TransactionCallbackWithoutResult() { @Override protected void doInTransactionWithoutResult(TransactionStatus status) { log.debug(\"entityManager: {}\", entityManager); Movie movie = Movie.builder() .name(\"Joker\") .build(); entityManager.persist(movie); } }); } } This approach is certainly more verbose, but it allows us to fix the issue. Let’s check the logs: 2022-05-16 07:02:29.688 DEBUG 1494469 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [null]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-16 07:02:29.702 DEBUG 1494469 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(541713794\u003copen\u003e)] for JPA transaction 2022-05-16 07:02:29.704 DEBUG 1494469 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@45b7c97f] 2022-05-16 07:02:29.704 DEBUG 1494469 --- [main] i.e.spring.tx.management.MovieService: entityManager: Shared EntityManager proxy for target factory [org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean@74123110] 2022-05-16 07:02:29.715 DEBUG 1494469 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-16 07:02:29.715 DEBUG 1494469 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(541713794\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-16 07:02:29.728 DEBUG 1494469 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(541713794\u003copen\u003e)] after transaction As we can see, we do have a transaction and the JPA entity was successfully inserted. ","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:4:1","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"Listening to the ContextRefreshedEvent event Another option would be to not use the @PostConstruct annotation, but listening to the ContextRefreshedEvent event, which is a spring event which is published after the Spring’s ApplicationContext is refreshed. At this stage, the proxies for our spring beans are guaranteed to be ready. It looks something like this: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } } @Service @Slf4j class MovieService { @Autowired private EntityManager entityManager; public MovieService() { log.debug(\"entityManager: {}\", entityManager); } @EventListener(ContextRefreshedEvent.class) @Transactional public void init() { log.debug(\"entityManager: {}\", entityManager); Movie movie = Movie.builder() .name(\"Joker\") .build(); entityManager.persist(movie); } } In the example above, instead of the @PostConstruct annotation, we’re using the @EventListener(ContextRefreshedEvent.class) annotation. Let’s check the logs to see if our JPA entity was inserted properly: 2022-05-16 07:13:27.686 DEBUG 1495276 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.init]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-16 07:13:27.687 DEBUG 1495276 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(235386075\u003copen\u003e)] for JPA transaction 2022-05-16 07:13:27.688 DEBUG 1495276 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@6f2d3391] 2022-05-16 07:13:27.693 DEBUG 1495276 --- [main] i.e.spring.tx.management.MovieService: entityManager: Shared EntityManager proxy for target factory [org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean@69d103f0] 2022-05-16 07:13:27.698 DEBUG 1495276 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-16 07:13:27.698 DEBUG 1495276 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(235386075\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-16 07:13:27.705 DEBUG 1495276 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(235386075\u003copen\u003e)] after transaction As we can see, we do have a transaction this time and the JPA entity was successfully inserted. ","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:4:2","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"Proxy self-injection This is the messiest and odd-looking solution that actually works. Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } } @Service @Slf4j class MovieService { @Autowired private EntityManager entityManager; @Autowired private MovieService proxy; public MovieService() { log.debug(\"entityManager: {}\", entityManager); } @PostConstruct public void init() { log.debug(\"entityManager: {}\", entityManager); proxy.doInit(); } @Transactional public void doInit() { Movie movie = Movie.builder() .name(\"Joker\") .build(); entityManager.persist(movie); } } In the example above, the MovieService tries to @Autowire itself. There are versions of the Spring framework (below 4.3) in which this trick doesn’t work. Starting with Spring Framework 4.3, support for self-injection with the @Autowired annotation was added, see release notes here. To make it work, we need to add in the application.properties file the following property (otherwise an UnsatisfiedDependencyException will be thrown): spring.main.allow-circular-references=true When we do a “self-injection” with the @Autowired annotation, what we actually get is our proxy! In this case, we can try to call a @Transactional method though the proxy and in this way we’ll get a transaction. For that we’ve added a new public method annotated with the @Transactional annotation. Let’s check the logs to see if it actually works: 2022-05-16 07:31:05.159 DEBUG 1526158 --- [main] i.e.spring.tx.management.MovieService: entityManager: null 2022-05-16 07:31:05.183 DEBUG 1526158 --- [main] i.e.spring.tx.management.MovieService: entityManager: Shared EntityManager proxy for target factory [org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean@27c53c32] 2022-05-16 07:31:05.195 DEBUG 1526158 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.doInit]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-16 07:31:05.208 DEBUG 1526158 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(266906347\u003copen\u003e)] for JPA transaction 2022-05-16 07:31:05.210 DEBUG 1526158 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@42107318] 2022-05-16 07:31:05.228 DEBUG 1526158 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-16 07:31:05.228 DEBUG 1526158 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(266906347\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-16 07:31:05.240 DEBUG 1526158 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(266906347\u003copen\u003e)] after transaction Indeed, our JPA entity was successfully inserted into the database. Note When doing the proxy self-injection, at the moment when the @PostConstruct method is invoked, it is obvious that the proxy for our MovieService is ready (since @PostConstruct methods are called after all of the bean’s dependencies we’re set). What if we try to rewrite our example like this?: @Service @Slf4j class MovieService { @Autowired private EntityManager entityManager; @Autowired private MovieService proxy; public MovieService() { log.debug(\"entityManager: {}\", entityManager); } @PostConstruct @Transactional public void init() { log.debug(\"entityManager: {}\", entityManager); Movie movie = Movie.builder() .name(\"Joker\") .build(); entityManager.persist(movie); } } Unfortunately it still won’t work because of the way the CommonAnnotationBeanPostProcessor was implemented (well, to be more precise its superclass - the InitDestroyAnnotationBeanPostProcessor), and it is the one which is calling the @PostConstruct methods. This BeanPostPro","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:4:3","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"Other pitfalls like this When the @PostConstruct methods are called, any proxy-based mechanisms (like @Async, @Secured, @Cacheable) do not work, but the fixes we’ve discussed in this blog post can be applicable. For example, if we try to make the @PostConstruct method asynchronous, like this: @Slf4j @SpringBootApplication @EnableAsync public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } } @Service @Slf4j class MovieService { @PostConstruct @Async public void init() { log.debug(\"Initializing MovieService\"); } } It won’t work the way we expect it to. The MovieService.init() will be called from the main thread, not in a different one. See the logs below: 2022-05-16 08:36:36.779 DEBUG 1532607 --- [main] i.e.spring.tx.management.MovieService : Initializing MovieService But if we try to apply the trick Listening to the ContextRefreshedEvent event, everything works as expected: @Slf4j @SpringBootApplication @EnableAsync public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } } @Service @Slf4j class MovieService { @EventListener(ContextRefreshedEvent.class) @Async public void init() { log.debug(\"Initializing MovieService\"); } } By looking at the logs we can see that this time, the MovieService.init() method was called from the task-1 thread. 2022-05-16 08:38:55.242 DEBUG 1532809 --- [task-1] i.e.spring.tx.management.MovieService : Initializing MovieService ","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:5:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"Conclusion In this blog post we’ve looked at one limitation of Spring’s declarative transaction management - the fact that it can’t be used in @PostConstruct methods, since the proxy is not ready yet at that point in time. We also looked at a couple of possible fixes to this problem, like using the programmatic approach, doing proxy self-injection or listening to the ContextRefreshedEvent. Finally, we’ve discussed that this problem can be encountered when using other proxy-based mechanisms like @Async, @Secured or even @Cacheable. There are also a couple of more puzzlers regarding the @Transactional annotation, we’ll take a look at them in another blog post. The code can be found on GitHub ","date":"2022-05-15","objectID":"/posts/spring_puzzler_transactional_poostconstruct_methods/:6:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Spring puzzler: transactional @PostConstruct methods","uri":"/posts/spring_puzzler_transactional_poostconstruct_methods/"},{"categories":["Spring Framework"],"content":"Introduction In this blog post we are going to explore the internals of Spring’s declarative transaction management. We’ll start with the basics, and then we’ll dive deeper, looking at the internals and some potential pitfalls which we can run into. We’ll be using: Spring Boot 2.6.7 Java 17 Postgresql Spring Data JPA But first, let’s discuss a bit why do we even bother with transactions in the first place? ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:1:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Why do we need transactions? The most common reason for using transactions in an application is to maintain a high degree of data integrity and consistency. If we’re unconcerned about the quality of our data, we don’t need to concern ourselves with transactions. Transaction management is ubiquitous, it is present in every Java application which uses a database. The Spring Framework out of the box provides a lot of mechanisms to manage transactions and though it makes our lives easier, it is quite important to understand how it works and what happens under the hood since there are some pitfalls which can lead to undesired results. Let’s take a closer look at what transaction management mechanism Spring provides and how we can use them. Transactions ensure data integrity trough ACID guarantees, which can be recapped as: Atomicity Each transaction is “all or nothing”. All SQL statements in a transaction (select, insert, update, merge or delete) is treated as a single unit. Either all statements are executed, or none of it is executed. Consistency After a transaction, the database is guaranteed to be in a consistent state (all the integrity constraints will be satisfied) Isolation Concurrent transactions don’t interfere with or affect one another. Well, almost. It is possible to have some interference, depending on the used transaction isolation level. Durability Ensures that changes to your data made by successfully executed transactions will be saved, even in the event of system failure Let’s take a look at a practical example. Let’s try to insert into the database the following JPA entity 3 times: @MappedSuperclass public class AbstractEntity { @Id @GenericGenerator(name = \"uuid-generator\", strategy = \"org.hibernate.id.UUIDGenerator\") @GeneratedValue(generator = \"uuid-generator\") protected String id; protected AbstractEntity() { } public String getId() { return id; } public boolean equals(Object other) { if (!(other instanceof AbstractEntity otherEntity)) return false; return Objects.equals(id, otherEntity.getId()); } public int hashCode() { return getClass().hashCode(); } } @Entity @Table(name = \"movies\") public class Movie extends AbstractEntity { private String name; protected Movie() { } private Movie(MovieBuilder builder) { this.name = builder.name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Movie{\" + \"name='\" + name + '\\'' + \", id='\" + id + '\\'' + '}'; } public static MovieBuilder builder() { return new MovieBuilder(); } public static class MovieBuilder { private String name; public MovieBuilder name(String name) { this.name = name; return this; } public Movie build() { return new Movie(this); } } } In order to do that, we can create the following Spring Data JPA repository: @Repository public interface MovieRepository extends JpaRepository\u003cMovie, String\u003e { } We can use the MovieRepository presented above and try to insert 3 movies into the database, like shown below: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { List\u003cString\u003e movieNames = List.of( \"Pulp fiction\", \"Joker\", \"Snatch\" ); List\u003cMovie\u003e savedMovies = movieService.saveMovies(movieNames); log.debug(\"Saved movies: {}\", savedMovies); }; } } @Service class MovieService { private final MovieRepository movieRepository; public MovieService(MovieRepository movieRepository) { this.movieRepository = movieRepository; } public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { return movieNames.stream() .map(movieName -\u003e Movie.builder() .name(movieName) .build() ) .map(movieRepository::save) .toList(); } } The question is, how many database transactions are executed by the MovieService.saveMovies() method? The answer is 3, becau","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:2:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"How to fix it? To make the MovieService.saveMovies() method atomic and obtain the “all or nothing” behavior, we can just annotate the method with @Transactional annotation. This time the org.springframework.data.jpa.repository.support.SimpleJpaRepository.save() won’t create a new transaction every time it is called but it will notice that with the current thread an active transaction is associated and it will join it. It will look like this: @Service class MovieService { private final MovieRepository movieRepository; public MovieService(MovieRepository movieRepository) { this.movieRepository = movieRepository; } @Transactional public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { return movieNames.stream() .map(movieName -\u003e Movie.builder() .name(movieName) .build() ) .map(movieRepository::save) .toList(); } } If we try to run the example this time, we should see the following in the logs: 2022-05-10 19:00:25.049 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-10 19:00:25.049 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.050 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@376b5cb2] 2022-05-10 19:00:25.056 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Found thread-bound EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.056 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Participating in existing transaction 2022-05-10 19:00:25.064 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Found thread-bound EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.064 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Participating in existing transaction 2022-05-10 19:00:25.065 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Found thread-bound EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.065 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Participating in existing transaction 2022-05-10 19:00:25.065 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction commit 2022-05-10 19:00:25.065 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Committing JPA transaction on EntityManager [SessionImpl(2139895366\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into movies (name, id) values (?, ?) 2022-05-10 19:00:25.079 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Closing JPA EntityManager [SessionImpl(2139895366\u003copen\u003e)] after transaction Notice that the Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT sequence is present only once this time, meaning we have a single transaction, as we expected. It’s also interesting that the transaction name has changed. Not it’s inc.evil.spring.tx.management.MovieService.saveMovies which is precisely the fully qualified method name which was annotated with the @Transactional annotation. Also in the logs we can see Participating in existing transaction 3 times, meaning that the org.springframework.data.jpa.repository.support.SimpleJpaRepository.save() method has joined the transaction created by the inc.evil.spring.tx.management.MovieService.saveMovies() method 3 times. Since Spring Data Jpa as a last resort creates transactions for us, during the following examples we are going to use Hibernate’s EntityManager directly because it doesn’t create any transactions and at the same time some of its methods throw exceptions if they’re called without an active","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:2:1","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Types of transaction management The Spring Framework provides us with 2 types of transaction management: Programmatic transaction management With this approach we manually create, commit and roll-back transactions Declarative transaction management With this approach, we just declare that we want a transaction, via an annotation and Spring will take care of the rest Let’s take a look at how both of these approaches look like in practice. ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Programmatic transaction management As we mentioned, by using the programmatic transaction management approach, we will have to manually create and commit transactions. This is not the preferred approach nowadays, but it does have its use-cases. Before showing any code examples, it’s worth mentioning that when it comes to transaction management (doesn’t matter declarative or programmatic), the entry-point is a spring bean of type PlatformTransactionManager with the name transactionManager. There are different implementations of the PlatformTransactionManager interface, depending on the environment we’re using. Some noteworthy implementations are: org.springframework.orm.jpa.JpaTransactionManager: if we intend to use Hibernate (with or without Spring Data Jpa) org.springframework.jdbc.datasource.DataSourceTransactionManager: if we intend to use sping-jdbc (with the JdbcTemplate) or Springh Data Jdbc org.springframework.transaction.jta.JtaTransactionManager: if we intend to use distributed (or XA) transactions (meaning transactions spanning more than one transactional resource, like a database and a message queue). Although XA transactions look nice, it’s considered a relic of the past and it’s best to be avoided since it has some problems and is not supported by many modern technologies (like Apache Kafka for example). Using the programmatic transaction management involves using directly the PlatformTransactionManager. As we can see below, it’s rather cumbersome to use. The first thing we need to do is to instantiate a DefaultTransactionDefinition which we can use to specify the desired propagation behavior, transaction name, the isolation level, the transaction timeout and the transaction read-only flag. After that by calling the PlatformTransactionManager.getTransaction(TransactionDefinition) method we effectively start the transaction with the desired attributes, execute the unit of work, and then we can try to commit it. If at some point the transaction was marked as rollback-only, it cannot be committed and the only possible outcome is a transaction rollback. @Service class ProgrammaticTxMovieService { private final EntityManager entityManager; private final PlatformTransactionManager transactionManager; public ProgrammaticTxMovieService(EntityManager entityManager, PlatformTransactionManager transactionManager) { this.entityManager = entityManager; this.transactionManager = transactionManager; } public Movie saveMovie(String movieName) { DefaultTransactionDefinition definition = new DefaultTransactionDefinition(); definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); definition.setName(\"saveMovie\"); TransactionStatus transaction = transactionManager.getTransaction(definition); try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); return movie; } catch (Exception e) { transaction.setRollbackOnly(); throw e; } finally { transactionManager.commit(transaction); } } } It’s worth mentioning that injecting the EntityManager directly into a service is kind of an unorthodox approach since services shouldn’t directly talk to the database but should delegate to a DAO instead. The rule was broken for the sake of brevity. A slightly simpler approach is to use the TransactionTemplate class which basically abstracts away the commit and rollback logic. Instead or writing this logic ourselves, we pass a callback. If the callback will not throw any exceptions, the transaction will be committed, otherwise a rollback will happen. @Service class TransactionTemplateProgrammaticTxMovieService { private final EntityManager entityManager; private final PlatformTransactionManager transactionManager; public TransactionTemplateProgrammaticTxMovieService(EntityManager entityManager, PlatformTransactionManager transactionManager) { this.entityManager = entityManager; this.transactionManager = transactionManager; } public Movie saveMovie(String movieName) { DefaultTransactionDefinition def","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:1","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Declarative transaction management With declarative transaction management, we just specify for what methods we want transactional behavior by annotating them with the @Transactional annotation and Spring will take care of the rest. It works something like this: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { List\u003cString\u003e movieNames = List.of( \"Pulp fiction\", \"Joker\", \"Snatch\" ); List\u003cMovie\u003e savedMovies = movieService.saveMovies(movieNames); log.debug(\"Saved movies: {}\", savedMovies); }; } } @Service class MovieService { private final MovieRepository movieRepository; public MovieService(MovieRepository movieRepository) { this.movieRepository = movieRepository; } @Transactional public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { return movieNames.stream() .map(movieName -\u003e Movie.builder() .name(movieName) .build() ) .map(movieRepository::save) .toList(); } } But how exactly does it work? We just annotated a method with an annotation and somehow that method now executes within a transaction. But who starts the transaction? Who commits or rolls-back it? The answer is simple, it’s a proxy! Just as a refresher, the proxy pattern looks like this: We have the Subject interface with the implementation Real Subject. We also have a Proxy which implements the Subject interface, so the proxy looks like a real Subject but it adds additional behavior like caching, logging, security or even transactions. The proxy also has a reference to the real implementation. The client, though unaware of this, will use the Proxy thinking it’s “the real thing”. Let’s try to log the actual class name of the MovieService, and see what’s really going on. @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { log.debug(\"MovieService actual class name: {}\", movieService.getClass().getName()); }; } then, in the logs we will see something like this: 2022-05-11 09:01:10.367 DEBUG 498664 --- [main] SpringDeclarativeTxManagementApplication: MovieService actual class name: inc.evil.spring.tx.management.MovieService$$EnhancerBySpringCGLIB$$38b14d5 We can observe that the actual class name is inc.evil.spring.tx.management.MovieService$$EnhancerBySpringCGLIB$$38b14d5, but in our codebase we have a simple MovieService. Because our MovieService has methods annotated with @Transactional annotation, Spring has created a CGLib proxy for our service and all the logic regarding transaction creation, commit or roll-back is executed precisely by that proxy. So, whenever we have a service which has methods annotated with the @Transactional annotation, Spring will create a proxy for that service and put it in the ApplicationContext. Wherever we want to inject that service, a proxy will be injected instead. The proxy will intercept all the public method calls, check if the method needs a transaction and if so, it will create it and then it will delegate to the original MovieService. After the original method from the MovieService was executed, the proxy will then commit or rollback the transaction, depending on what (if any) exceptions were thrown. As a sequence diagram, the flow looks like this: We can summarize the flow like this: The CommandLineRunner calls MovieService.saveMovies() method. What the CommandLineRunner doesn’t know is that it actually has a reference to a proxy. So in reality the CommandLineRunner is invoking a proxy (a class generated by CGLib in runtime, which looks like a MovieService but it’s a completely different class called MovieService$$EnhancerBySpringCGLIB$$38b14d5) The proxy (the MovieService$$EnhancerBySpringCGLIB$$38b14d5 class) sees that the invoked method (the saveMovies method) is annotated with the @Transactional annotation, so we need a transaction mos","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:2","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional method visibility By default, only public methods can be annotated with the @Transactional annotation. What will happen if we try to make a @Transactional method package-private or protected? Let’s have a look (notice that the MovieService.saveMovie method is package-private): @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); return movie; } } We’ll get a TransactionRequiredException thrown by the EntityManager.persist() method because we don’t have an active transaction (see logs below): 2022-05-12 12:51:40.418 INFO 1079474 --- [main] SpringDeclarativeTxManagementApplication : Started SpringDeclarativeTxManagementApplication in 1.079 seconds (JVM running for 1.355) 2022-05-12 12:51:40.420 INFO 1079474 --- [main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-05-12 12:51:40.428 ERROR 1079474 --- [main] o.s.boot.SpringApplication : Application run failed java.lang.IllegalStateException: Failed to execute CommandLineRunner at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:780) ~[spring-boot-2.6.7.jar:2.6.7] at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:761) ~[spring-boot-2.6.7.jar:2.6.7] at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[spring-boot-2.6.7.jar:2.6.7] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) ~[spring-boot-2.6.7.jar:2.6.7] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) ~[spring-boot-2.6.7.jar:2.6.7] at inc.evil.spring.tx.management.SpringDeclarativeTxManagementApplication.main(SpringDeclarativeTxManagementApplication.java:35) ~[classes/:na] Caused by: javax.persistence.TransactionRequiredException: No EntityManager with actual transaction available for current thread - cannot reliably process 'persist' call at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:295) ~[spring-orm-5.3.19.jar:5.3.19] at jdk.proxy2/jdk.proxy2.$Proxy80.persist(Unknown Source) ~[na:na] at inc.evil.spring.tx.management.MovieService.saveMovie(SpringDeclarativeTxManagementApplication.java:162) ~[classes/:na] at inc.evil.spring.tx.management.SpringDeclarativeTxManagementApplication.lambda$commandLineRunner$0(SpringDeclarativeTxManagementApplication.java:41) ~[classes/:na] at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:777) ~[spring-boot-2.6.7.jar:2.6.7] ... 5 common frames omitted It turns out that we can enable the transactional behavior for package-private and protected methods (private is the exception) by adding a bit of configuration. To do this, we should add in our Java configuration the @EnableTransactionManagement(proxyTargetClass = true) and add in the application context the following spring bean: @Bean public TransactionAttributeSource transactionAttributeSource() { return new AnnotationTransactionAttributeSource(false); } The TransactionAttributeSource constructor has a parameter called publicMethodsOnly (and by default it is set to true) which specifies if only public methods should have the transactional behavior. By setting this flag to false, we obtain transactional behavior for package-private and protected methods as well. Also sin","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:3","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Commit and roll-back rules By default (though this can be configured) the transaction will be committed if: No exceptions were thrown Checked exceptions were thrown In other cases (if unchecked exceptions were thrown, meaning instances or subclasses of RuntimeException), the transaction will be rolled-back. It is surprising that the transaction is committed in case of checked exceptions. The rationale is that checked exceptions are considered business exceptions and we should check the business rules to see if we do need a rollback or not. Let’s try to test it! What do you think will happen when we’ll call the MovieService.saveMovies() method shown below? @Service class MovieService { @Transactional public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { throw new IllegalArgumentException(); } } Since IllegalArgumentException extends RuntimeException, it is considered an unchecked exception and the transaction will be rolled-back. Let’s look at the logs: 2022-05-11 09:22:17.287 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 09:22:17.287 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1159911315\u003copen\u003e)] for JPA transaction 2022-05-11 09:22:17.288 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@37fef327] 2022-05-11 09:22:17.292 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction rollback 2022-05-11 09:22:17.292 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Rolling back JPA transaction on EntityManager [SessionImpl(1159911315\u003copen\u003e)] 2022-05-11 09:22:17.293 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(1159911315\u003copen\u003e)] after transaction 2022-05-11 09:22:17.294 INFO 505977 --- [main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-05-11 09:22:17.303 ERROR 505977 --- [main] o.s.boot.SpringApplication : Application run failed java.lang.IllegalStateException: Failed to execute CommandLineRunner The transaction was indeed rolled-back. Now let’s see what happens if we will use a checked-exception: @Service class MovieService { @Transactional public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) throws IOException { throw new IOException(); } } This time we throw a IOException which extends from Exception which makes it a checked-exception. In this case, even though an exception was thrown out of the @Transactional method, we will have a commit, as seen in the logs below: 2022-05-11 09:26:23.561 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 09:26:23.562 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(347691330\u003copen\u003e)] for JPA transaction 2022-05-11 09:26:23.563 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@775f15fd] 2022-05-11 09:26:23.566 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-11 09:26:23.566 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(347691330\u003copen\u003e)] 2022-05-11 09:26:23.567 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(347691330\u003copen\u003e)] after transaction 2022-05-11 09:26:23.567 INFO 507376 --- [main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To displ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:4","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"How to configure the commit-rollback behavior? It is possible to specify the desired transaction outcome by using the following attributes of the @Transactional annotation: @Transactional(rollbackFor = ...): an array of exception classes for which we want the transaction rolled-back. If we use for example @Transactional(rollbackFor = Exception.class), then we’ll have a rollback if the @Transactional method throws an Exception or any of its subclasses @Transactional(rollbackForClassName = \"...\"): same as above but this time the exception class name is specified as a string. Wildcards are not supported, but we can omit the package and use only the class name, like this: @Transactional(noRollbackForClassName = \"IOException\") or like this @Transactional(noRollbackForClassName = \"java.io.IOException\") it’s the same thing @Transactional(noRollbackFor = ...): an array of exception classes for which we want the transaction committed. @Transactional(noRollbackForClassName = \"...\"): same as above but this time the exception class name is specified as a string. Let’s try to test it. What do you think will happen when we’ll call the MovieService.saveMovies() method shown below? @Service class MovieService { @Transactional(rollbackFor = IOException.class) public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) throws IOException { throw new IOException(); } } The transaction will be rolled-back. Even though a checked-exception was thrown, we specified that we want a rollback in case of an IOException is thrown, and that’s exactly what we’ve got (see the logs below): 2022-05-11 10:02:49.324 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.io.IOException 2022-05-11 10:02:49.324 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(1207093026\u003copen\u003e)] for JPA transaction 2022-05-11 10:02:49.326 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@7608a838] 2022-05-11 10:02:49.330 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction rollback 2022-05-11 10:02:49.330 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Rolling back JPA transaction on EntityManager [SessionImpl(1207093026\u003copen\u003e)] 2022-05-11 10:02:49.331 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Closing JPA EntityManager [SessionImpl(1207093026\u003copen\u003e)] after transaction Now let’s do the opposite with an unchecked-exception. What do you think will happen when we’ll call the method shown below? @Service class MovieService { @Transactional(noRollbackFor = IllegalArgumentException.class) public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { throw new IllegalArgumentException(); } } The transaction will be committed since we’ve specified that we don’t want to rollback in case an IllegalArgumentException exception is thrown (see the logs below): 2022-05-11 10:06:57.206 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,+java.lang.IllegalArgumentException 2022-05-11 10:06:57.206 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(1692381981\u003copen\u003e)] for JPA transaction 2022-05-11 10:06:57.207 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@2cd3fc29] 2022-05-11 10:06:57.210 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction commit 2022-05-11 10:06:57.211 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Committing JPA transaction on EntityManager [SessionImpl(1692381981\u003copen\u003e)] 2022-05-11 ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:5","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Is programmatic transaction management equivalent to the declarative one? What if we take a method which uses the declarative transaction management approach and try to rewrite it to use the programmatic approach? Do we get the same behavior? Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) throws IOException { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); offendingMethod(); return movie; } private void offendingMethod() throws IOException { throw new IOException(); } } The method throws an IOException, which is a checked-exception so that means that the transaction will be committed, even though the method thew an exception (see the logs below): 2022-05-12 10:26:06.788 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 10:26:06.788 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(1871084300\u003copen\u003e)] for JPA transaction 2022-05-12 10:26:06.790 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@be6d228] 2022-05-12 10:26:06.797 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction commit 2022-05-12 10:26:06.798 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Committing JPA transaction on EntityManager [SessionImpl(1871084300\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-12 10:26:06.810 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(1871084300\u003copen\u003e)] after transaction 2022-05-12 10:26:06.811 INFO 1024681 --- [main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-05-12 10:26:06.819 ERROR 1024681 --- [main] o.s.boot.SpringApplication : Application run failed java.lang.IllegalStateException: Failed to execute CommandLineRunner Now let’s rewrite the method to use the programmatic transaction management approach using the TransactionTemplate, as shown below: @Service @Slf4j class MovieService { private final EntityManager entityManager; private final PlatformTransactionManager transactionManager; public MovieService(EntityManager entityManager, PlatformTransactionManager transactionManager) { this.entityManager = entityManager; this.transactionManager = transactionManager; } public Movie saveMovie(String movieName) throws IOException { DefaultTransactionDefinition definition = new DefaultTransactionDefinition(); definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); definition.setName(\"saveMovie\"); TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager, definition); return transactionTemplate.execute(status -\u003e { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); offendingMethod(); //does not compile return movie; }); } private void offendingMethod() throws IOException { throw new IOException(); } } Well, the code above does not compile since the TransactionTemplate.execute(TransactionCallback callback) method have a parameter of type TransactionCallback, which is a functional interface which d","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:6","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Transaction propagation What will happen if we’ll call one @Transactional method from another? Will we have 2 transactions or just one? Let’s run the example below and look at the logs. We have 2 services: MovieService and MovieServiceTwo. First we call the transactional MovieService.saveMovie() method and then it tries to invoke the MovieServiceTwo.save() which is also transactional. @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final MovieServiceTwo movieServiceTwo; public MovieService(MovieServiceTwo movieServiceTwo) { this.movieServiceTwo = movieServiceTwo; } @Transactional public Movie saveMovie(String movieName) { log.debug(\"Inside MovieService\"); Movie movie = Movie.builder() .name(movieName) .build(); return movieServiceTwo.save(movie); } } @Service @Slf4j class MovieServiceTwo { private final EntityManager entityManager; public MovieServiceTwo(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional public Movie save(Movie movie) { log.debug(\"Inside MovieServiceTwo\"); entityManager.persist(movie); return movie; } } If we look at the logs, we can see that we have a single transaction: 2022-05-11 15:34:42.455 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 15:34:42.455 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(2020226167\u003copen\u003e)] for JPA transaction 2022-05-11 15:34:42.457 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@46b6701e] 2022-05-11 15:34:42.460 DEBUG 690207 --- [main] i.e.s.tx.management.MovieService : Inside MovieService 2022-05-11 15:34:42.460 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(2020226167\u003copen\u003e)] for JPA transaction 2022-05-11 15:34:42.460 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-11 15:34:42.463 DEBUG 690207 --- [main] i.e.s.tx.management.MovieServiceTwo : Inside MovieServiceTwo 2022-05-11 15:34:42.468 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-11 15:34:42.468 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(2020226167\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-11 15:34:42.481 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(2020226167\u003copen\u003e)] after transaction What happened is that the proxy for MovieServiceTwo has found an existing transaction for the current thread and it joined it. Basically transactions are like a viral disease, they can infect other methods. The @Transactional annotation has an attribute called propagation and it specifies the desired behavior when a transactional method is called with or without an active transaction. Here are the possible propagation levels: @Transactional(propagation = Propagation.REQUIRED): the default. Starts a transaction if we don’t have one, otherwise join the existing one @Transactional(propagation = Propagation.REQUIRES_NEW): Starts a transaction if we don’t have one, otherwise suspend the existing one and create a new one @Transactional(propagation = Propagation.SUPPORTS): Join the existing transaction. If we don’t have a transaction execute without it @Transactional(propagation = Propagation.MANDATORY): Join the existing transaction","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.REQUIRED) When calling a method annotated with @Transactional(propagation = Propagation.REQUIRED), if the current thread is not associated with a transaction, a new transaction will be created. If a transaction exists, the method will just join it. But what will happen if one @Transactional method calls another @Transactional method from a different service, with propagation = Propagation.REQUIRED and the second service throws an exception? Do we lose all the work done by the first service as well or only the work done by the second service? Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } catch (Exception e) { log.error(\"Caught an exception\"); return null; } } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); throw new NullPointerException(); } } If we look at the logs, we can see that the ActorService.saveActor() method has joined the existing transaction (the Participating in existing transaction) and because it threw an exception, the transaction was marked as rollback-only by the proxy. Because the transaction was marked as rollback-only, it cannot be committed, even though it tried to (see Initiating transaction commit in the logs). Also we can notice that trying to catch the exception didn’t help at all, since the exception “passed though” the proxy and because of that , it has set the rollback-only flag. We can also observe that all of the database work done by both services was lost (or rolled-back) since we don’t have any SQL statements logged (we’ve configured Hibernate to do so). 2022-05-11 17:02:05.767 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 17:02:05.767 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1478683866\u003copen\u003e)] for JPA transaction 2022-05-11 17:02:05.769 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@3ee6dc82] 2022-05-11 17:02:05.777 DEBUG 716638 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-11 17:02:05.778 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1478683866\u003copen\u003e)] for JPA transaction 2022-05-11 17:02:05.778 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-11 17:02:05.781 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating transaction failed - marking existing transaction as rollback-only 2022-05-11 17:02:05.781 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Setting JPA transaction on EntityManager [SessionImpl(1","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:1","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.REQUIRES_NEW) When calling a method annotated with @Transactional(propagation = Propagation.REQUIRES_NEW), if the current thread is not associated with a transaction, a new transaction will be created. If a transaction exists, the existing transaction will be suspended and we’ll create a new one, execute it and then finally we’ll resume the initial one. But what will happen if one @Transactional method calls another @Transactional(propagation = Propagation.REQUIRES_NEW) method from a different service, and the second service throws an exception? In this case we have 2 transactions and we expect a rollback only for the second transaction. Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } catch (Exception e) { log.error(\"Caught an exception\"); return null; } } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRES_NEW) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); throw new NullPointerException(); } } Looking at the logs we can observe that when the ActorService.saveActor() method is called, the existing transaction is indeed suspended (Suspending current transaction, creating new transaction with name [inc.evil.spring.tx.management.ActorService.saveActor]). When the ActorService.saveActor() throws an exception, the new transaction is rollbacked (Rolling back JPA transaction on EntityManager [SessionImpl(1959219756\u003copen\u003e)]) and then the initial transaction is resumed (Resuming suspended transaction after completion of inner transaction). Since the MovieService.saveMovie() catches the exception thrown by the ActorService.saveActor(), no exceptions will “pass though” the proxy of the MovieService class and that means that the initial transaction will be committed (see the logs below). If we were to remove the try-catch block from the MovieService.saveMovie() method, both transactions will be rolled-back. We can also observe that the work done by the MovieService.saveMovie() is preserved, we have an insert SQL statement in the logs. 2022-05-11 17:19:29.308 DEBUG 721804 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 17:19:29.308 DEBUG 721804 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1598068850\u003copen\u003e)] for JPA transaction 2022-05-11 17:19:29.310 DEBUG 721804 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@506aa618] 2022-05-11 17:19:29.318 DEBUG 721804 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-11 17:19:29.318 DEBUG 721804 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1598068850\u003copen\u003e)] for JPA transaction 2022-05-11 17:19:29.319 DEBUG 7218","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:2","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.NESTED) The propagation = Propagation.NESTED works pretty much the same way as propagation = Propagation.REQUIRES_NEW, if the current thread is not associated with a transaction, a new transaction will be created. If a transaction exists, we’ll create a JDBC Savepoint before entering the new transactional method and in case of failure we will rollback to the jdbc savepoint. Basically if one @Transactional method calls another @Transactional(propagation = Propagation.NESTED) method from a different service, and the second service throws an exception, we will rollback to the jdbc savepoint and in this way we’ll preserve the work done by the first service. Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } catch (Exception e) { log.error(\"Caught an exception\"); return null; } } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.NESTED) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); throw new NullPointerException(); } } 2022-05-11 17:43:55.526 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 17:43:55.527 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(711964207\u003copen\u003e)] for JPA transaction 2022-05-11 17:43:55.528 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@7e2bd5e6] 2022-05-11 17:43:55.536 DEBUG 729067 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-11 17:43:55.537 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(711964207\u003copen\u003e)] for JPA transaction 2022-05-11 17:43:55.537 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating nested transaction with name [inc.evil.spring.tx.management.ActorService.saveActor] 2022-05-11 17:43:55.537 ERROR 729067 --- [main] i.e.s.tx.management.MovieService: Caught an exception 2022-05-11 17:43:55.537 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-11 17:43:55.537 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(711964207\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-11 17:43:55.545 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(711964207\u003copen\u003e)] after transaction Looking at the logs we can see that only the work done by the MovieService.saveMovie() method was successfully inserted into the database. ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:3","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.SUPPORTS) This is an easy one, it works as if the @Transactional annotation is not present. If we have an active transaction, we join it. If we don’t, execute without a transaction. Let’s take a look at the example below: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } catch (Exception e) { log.error(\"Caught an exception\"); return null; } } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.SUPPORTS) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); return actor; } } We can see that the ActorService.saveActor which has @Transactional(propagation = Propagation.SUPPORTS) has joined the existing transaction, but if the @Transactional annotation wasn’t present, the same thing would happen. 2022-05-12 10:01:38.812 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 10:01:38.812 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1185631996\u003copen\u003e)] for JPA transaction 2022-05-12 10:01:38.814 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@40016ce1] 2022-05-12 10:01:38.822 DEBUG 1017539 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-12 10:01:38.822 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1185631996\u003copen\u003e)] for JPA transaction 2022-05-12 10:01:38.822 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-12 10:01:38.824 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-12 10:01:38.824 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(1185631996\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into actors (name, id) values (?, ?) 2022-05-12 10:01:38.832 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(1185631996\u003copen\u003e)] after transaction What will happen if both methods have the @Transactional(propagation = Propagation.SUPPORTS) annotation? Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManage","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:4","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.NOT_SUPPORTED) The @Transactional(propagation = Propagation.NOT_SUPPORTED) propagation works in the following way: if we don’t have a transaction, no problem, execute without it. If we do have one, suspend it, execute the method with the propagation = Propagation.NOT_SUPPORTED and then resume the transaction. Basically it is useful when we want to call a method from a different service which doesn’t need a transaction and at the same time we want to prevent that method from marking the transaction as rollback-only in case of exceptions. Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); try { actorService.saveActor(\"John Travolta\"); } catch (Exception e) { log.error(\"Caught an exception\"); } return movie; } } @Service @Slf4j class ActorService { @Transactional(propagation = Propagation.NOT_SUPPORTED) public Actor saveActor(String name) { throw new RuntimeException(); } } If we analyze the logs we can see that the ActorService.saveActor() suspends the transaction (Suspending current transaction) and then it resumes it (Resuming suspended transaction after completion of inner transaction). Even though the ActorService.saveActor() threw a RuntimeException which triggers a rollback usually, we successfully committed the transaction since the exception was thrown when the transaction was suspended (see logs below): 2022-05-12 11:18:46.933 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 11:18:46.933 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1421763091\u003copen\u003e)] for JPA transaction 2022-05-12 11:18:46.936 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@7eee6c13] 2022-05-12 11:18:46.947 DEBUG 1040575 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-12 11:18:46.948 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1421763091\u003copen\u003e)] for JPA transaction 2022-05-12 11:18:46.948 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Suspending current transaction 2022-05-12 11:18:46.951 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Should roll back transaction but cannot - no transaction available 2022-05-12 11:18:46.951 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Resuming suspended transaction after completion of inner transaction 2022-05-12 11:18:46.951 ERROR 1040575 --- [main] i.e.s.tx.management.MovieService: Caught an exception 2022-05-12 11:18:46.951 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-12 11:18:46.951 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(1421763091\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-12 11:18:46.964 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityMana","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:5","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.NEVER) This transaction propagation level does not support transactions. If we’ll call a method annotated with @Transactional(propagation = Propagation.NEVER) without a transaction, everything will work fine. If we do have a transaction, we’ll get an exception since the method doesn’t support transactions. This propagation level is useful for scenarios where we have a method which doesn’t need a transaction and we want to prevent others from calling the method when there’s an active transaction. It is considered that transactions should be as small as possible and we can use this propagation level to prevent a long-running method being called from a transaction, since that will increase significantly the transaction lifespan. Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.NEVER) public Movie saveMovie(String movieName) { return Movie.builder() .name(movieName) .build(); } } If we look at the logs, we can see that no transaction was created: 2022-05-12 11:41:01.254 INFO 1047157 --- [main] SpringDeclarativeTxManagementApplication : Started SpringDeclarativeTxManagementApplication in 1.045 seconds (JVM running for 1.338) 2022-05-12 11:41:01.260 INFO 1047157 --- [ionShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' Let’s try out a different example. What will happen if we call a @Transactional(propagation = Propagation.NEVER) with an active transaction, like shown below? @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } } @Service @Slf4j class ActorService { @Transactional(propagation = Propagation.NEVER) public Actor saveActor(String name) { return Actor.builder() .name(name) .build(); } } In this case a IllegalTransactionStateException will be thrown since the ActorService.saveActor() method does not support transactions (see logs below): 2022-05-12 11:43:01.090 DEBUG 1047930 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 11:43:01.090 DEBUG 1047930 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(711964207\u003copen\u003e)] for JPA transaction 2022-05-12 11:43:01.091 DEBUG 1047930 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@7e2bd5e6] 2022-05-12 11:43:01.100 DEBUG 1047930 --- [main] i.e.s.tx.man","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:6","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.MANDATORY) The @Transactional(propagation = Propagation.MANDATORY) is the opposite of Propagation.NEVER. In order to call a method with the @Transactional(propagation = Propagation.MANDATORY) we need to have an active transaction, otherwise we’ll get an exception. Let’s have a closer look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.MANDATORY) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); return actor; } } We can see from the logs that everything worked fine, we have a single transaction (started by MovieService.saveMovie()) and the ActorService.saveActor() has joined it: 2022-05-12 11:52:22.465 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 11:52:22.465 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1186328673\u003copen\u003e)] for JPA transaction 2022-05-12 11:52:22.466 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@376af784] 2022-05-12 11:52:22.475 DEBUG 1050965 --- [main] i.e.s.tx.management.MovieService : Calling ActorService 2022-05-12 11:52:22.475 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1186328673\u003copen\u003e)] for JPA transaction 2022-05-12 11:52:22.475 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-12 11:52:22.477 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-12 11:52:22.478 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(1186328673\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into actors (name, id) values (?, ?) 2022-05-12 11:52:22.491 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(1186328673\u003copen\u003e)] after transaction 2022-05-12 11:52:22.494 INFO 1050965 --- [ionShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' 2022-05-12 11:52:22.495 INFO 1050965 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown initiated... 2022-05-12 11:52:22.497 INFO 1050965 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown completed. Process finished with exit code 0 If we try to call a method annotated with @Transactional(propagation = Propagation.MANDATORY) without a transaction, we’ll get an exception: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:7","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Transaction timeouts The @Transactional annotation has an attribute called timeout which specifies the transaction timeout in seconds. If the transaction won’t be committed in the given number of seconds, it will be automatically rolled-back. The timeout attribute along with propagation = Propagation.REQUIRED sometimes has interesting behavior. When a method with propagation = Propagation.REQUIRED is joining an existing transaction, it inherits the transaction attributes like isolation, readOnly and timeout from the existing transaction. This could lead to unexpected results sometimes. Let’s look at an example. The MovieService.saveMovie() method is the one starting the transaction and it declares the transaction timeout as one second. The ActorService.saveActor() method will join the existing transaction, but it wants a timeout of 10 seconds. Also the ActorService.saveActor() has an artificial delay of 2 seconds. In this case, what do you think will happen? @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED, timeout = 1) public Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); actorService.saveActor(\"John Travolta\"); return movie; } } @Service @Slf4j class ActorService { @Transactional(propagation = Propagation.REQUIRED, timeout = 10) public Actor saveActor(String name) { try { TimeUnit.SECONDS.sleep(2); return null; } catch (InterruptedException e) { return null; } } } Well, if we look at the logs we can see that the transaction timed-out and was rolled-back, which basically means that ActorService.saveActor() method has inherited the timeout attribute from the existing transaction it has joined. The transaction was rolled-back since the transaction timeout was one second but the ActorService.saveActor() method executed for 2 seconds. 2022-05-12 15:18:16.374 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,timeout_1 2022-05-12 15:18:16.374 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(337295973\u003copen\u003e)] for JPA transaction 2022-05-12 15:18:16.376 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@d504137] 2022-05-12 15:18:16.384 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(337295973\u003copen\u003e)] for JPA transaction 2022-05-12 15:18:16.385 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-12 15:18:18.391 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-12 15:18:18.392 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(337295973\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-12 15:18:18.405 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction rollback after commit exception org.springframework.orm.jpa.JpaSystemException: transaction timeout expired; nested exception is org.hibernate.TransactionException: transaction timeout expired at org.springframework.o","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:5:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Read-only transactions When using the JpaTransactionManager (configured by default when using spring-data-jpa), every transaction which is created also creates an EntityManager which represents the so-called “unit of work” in Hibernate. Though the EntityManager is not thread-safe, it’s not a problem since transactions are thread-local (or bound to a specific thread). We can easily verify that when creating a new transaction an EntityManager is created as well by looking at the following example: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieServiceOne(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional protected Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); return movie; } } In the logs we can observe the sequence: Opened new EntityManager [SessionImpl(1982072255\u003copen\u003e)] for JPA transaction and Closing JPA EntityManager [SessionImpl(1982072255\u003copen\u003e)] after transaction. 2022-05-13 08:42:02.640 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieServiceOne.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-13 08:42:02.641 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(1982072255\u003copen\u003e)] for JPA transaction 2022-05-13 08:42:02.642 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@37a67cf] 2022-05-13 08:42:02.652 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction commit 2022-05-13 08:42:02.653 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Committing JPA transaction on EntityManager [SessionImpl(1982072255\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-13 08:42:02.665 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Closing JPA EntityManager [SessionImpl(1982072255\u003copen\u003e)] after transaction It is known that the EntityManager acts as a first-level cache (in different sources there’s different nomenclature for this, sometimes this is called that the EntityManager has a persistence context or that the EntityManager represents the persistence context), which basically is a cache for entities in the persistent state. The question which arrives at this point is: when a transactional method from one service joins an existing transaction (created by another service), is the EntityManager reused? Let’s have a look at an example: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieServiceOne movieService) { return args -\u003e { movieService.findMovie(\"aa3e4567-e89b-12d3-b457-5267141750aa\"); }; } } @Service @Slf4j class MovieServiceOne { private final EntityManager entityManager; private final MovieServiceTwo movieServiceTwo; public MovieServiceOne(EntityManager entityManager, MovieServiceTwo movieServiceTwo) { this.entityManager = entityManager; this.movieServiceTwo = movieServiceTwo; } @Transactional protected Movie findMovie(String id) { Movie movie = entityManager.find(Movie.class, id); log.debug(\"Found movie: {}\", movie); movieServiceTwo.findMovie(id); return movie; } } @Service @Slf4j class MovieServiceTwo { private final EntityManager entityManager; public MovieServiceTwo(EntityManager entityManager) { t","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:6:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"The readOnly attribute We can mark the transaction as being read-only by specifying the readOnly attribute, like this: @Transactional(readOnly = true). Read-only transactions are considered to be more performant and another effect of this attribute is that Hibernate's dirty-checking mechanisms would be disabled. When fetching an entity, Hibernate apart from the fact that it maps the ResultSet to a Java object, it creates a snapshot of the ResultSet so that it can use it later, at flush-time to determine if the entity is dirty (meaning we need to update the entity). With read-only transactions, this actions doesn’t take place and this is precisely the reason of performance improvement. Let’s check it. Take a look at the example below: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.findMovie(\"aa3e4567-e89b-12d3-b457-5267141750aa\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(readOnly = true) protected Movie findMovie(String id) { Movie movie = entityManager.find(Movie.class, id); log.debug(\"Found movie: {}\", movie); movie.setName(movie.getName() + \"!\"); return movie; } } In the example above, in a read-only transaction we fetch a Movie entity and change its name (making the entity dirty). If we had a regular “write” transaction, this will trigger an SQL update on the movie table. Let’s check the logs to see what happened in our case: 2022-05-13 19:22:55.713 DEBUG 1353141 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.findMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly 2022-05-13 19:22:55.713 DEBUG 1353141 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(196161345\u003copen\u003e)] for JPA transaction 2022-05-13 19:22:55.715 DEBUG 1353141 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@75dd0f94] Hibernate: select movie0_.id as id1_1_0_, movie0_.name as name2_1_0_ from movies movie0_ where movie0_.id=? 2022-05-13 19:22:55.724 DEBUG 1353141 --- [main] i.e.s.tx.management.MovieService : Found movie: Movie{name='Pulp Fiction!', id='aa3e4567-e89b-12d3-b457-5267141750aa'} 2022-05-13 19:22:55.725 DEBUG 1353141 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit No SQL updates spotted, signifying that the dirty-checking mechanism was indeed disabled. Good idea If the transaction only reads data, mark it as read-only. This wil not only improve the performance, but also serve as a form of documentation. Now, what will happen if in a readOnly transaction we’ll try to persist an entity, as shown in the example below? @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.findMovie(\"aa3e4567-e89b-12d3-b457-5267141750aa\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(readOnly = true) protected Movie findMovie(String id) { Movie movie = entityManager.find(Movie.class, id); log.debug(\"Found movie: {}\", movie); Movie newMovie = Movie.builder() .name(\"Joker\") .build(); entityManager.persist(newMovie); return movie; } } Well, the EntityManager.persist() will be silently ignored (without throwing any e","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:6:1","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Conclusion In this blog post we made a gentle introduction on Spring's declarative and programmatic transaction management approaches, looked at all the propagation levels, what’s the default commit and rollback behavior (and how to configure it), discussed that by default only public methods can be transactional, but with a bit of configuration we can enable the transactional behavior for package-private and protected methods as well. We also compared a bit the programmatic and declarative approaches and saw that they aren’t 100% equivalent, and we also saw that read-only transactions disable the dirty-checking mechanism. We’ll dive deeper in another blog post where we’ll look at some puzzlers and limitations of declarative transaction management. ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:7:0","tags":["Spring Framework","Declarative transaction management","Programmatic transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":null,"content":"I have about 5 years of experience in development using the Java programming language. I’m very passionate and driven by a desire to learn as much as possible about the Java platform and its ecosystem, (Spring Boot, Hibernate, AWS, Apache Kafka, Debezium and many more) and to implement high-quality solutions using industry best practices. ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"}]