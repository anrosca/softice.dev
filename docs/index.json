[{"categories":["Spring Framework"],"content":"Introduction In this blog post we are going to explore the internals of Spring’s declarative transaction management. We’ll start with the basics, and then we’ll dive deeper, looking at the internals and some potential pitfalls which we can run into. But first, let’s discuss a bit why do we even bother with transactions in the first place? ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:1:0","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Why do we need transactions? The most common reason for using transactions in an application is to maintain a high degree of data integrity and consistency. If we’re unconcerned about the quality of our data, we needn’t concern ourselves with transactions. Transaction management is ubiquitous, it is present is every Java application which uses a database. The Spring Framework out of the box provides a lot of mechanisms to manage transactions and though it makes our lives easier, it is quite important to understand how it works and what happens under the hood since there are some pitfalls which can lead to undesired results. Let’s take a closer look at what transaction management mechanism Spring provides and how we can use them. Suppose we have the following JPA entity: @Entity @Table(name = \"movies\") public class Movie extends AbstractEntity { private String name; protected Movie() { } private Movie(MovieBuilder builder) { this.name = builder.name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Movie{\" + \"name='\" + name + '\\'' + \", id='\" + id + '\\'' + '}'; } public static MovieBuilder builder() { return new MovieBuilder(); } public static class MovieBuilder { private String name; public MovieBuilder name(String name) { this.name = name; return this; } public Movie build() { return new Movie(this); } } } With the following Spring Data JPA repository: @Repository public interface MovieRepository extends JpaRepository\u003cMovie, String\u003e { } We can use the MovieRepository presented above and try to insert 3 movies into the database, like shown below: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { List\u003cString\u003e movieNames = List.of( \"Pulp fiction\", \"Joker\", \"Snatch\" ); List\u003cMovie\u003e savedMovies = movieService.saveMovies(movieNames); log.debug(\"Saved movies: {}\", savedMovies); }; } } @Service class MovieService { private final MovieRepository movieRepository; public MovieService(MovieRepository movieRepository) { this.movieRepository = movieRepository; } public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { return movieNames.stream() .map(movieName -\u003e Movie.builder() .name(movieName) .build() ) .map(movieRepository::save) .toList(); } } The question is, how many database transactions are executed by the MovieService.saveMovies() method? The answer is 3, because every call to MovieRepository.save() method creates a new transaction. To make sure that that’s really happening, we can set the debug log level for the JpaTransactionManager and in this way the JpaTransactionManager will publish logs every time it opens, commits or rolls-back transactions. Setting the debug log level can be accomplished by adding the following property in the application.properties file: #Logging properties logging.level.org.springframework.orm.jpa=debug If we run the application now, we can observe the following in the logs: 2022-05-10 18:23:56.122 DEBUG 336867 --- [ main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [org.springframework.data.jpa.repository.support.SimpleJpaRepository.save]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-10 18:23:56.122 DEBUG 336867 --- [ main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1337659716\u003copen\u003e)] for JPA transaction 2022-05-10 18:23:56.125 DEBUG 336867 --- [ main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@2c34402] 2022-05-10 18:23:56.134 DEBUG 336867 --- [ main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-10 18:23:56.135 DEBUG 336867 --- [ main] o.s.orm.jpa.JpaTransactionManager : C","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:2:0","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"How to fix it? To make the MovieService.saveMovies() method atomic and obtain the “all or nothing” behavior, we can just annotate the method with @Transactional annotation. It will look like this: @Service class MovieService { private final MovieRepository movieRepository; public MovieService(MovieRepository movieRepository) { this.movieRepository = movieRepository; } @Transactional public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { return movieNames.stream() .map(movieName -\u003e Movie.builder() .name(movieName) .build() ) .map(movieRepository::save) .toList(); } } If we try to run the example this time, we should see the following in the logs: 2022-05-10 19:00:25.049 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-10 19:00:25.049 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.050 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@376b5cb2] 2022-05-10 19:00:25.056 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.056 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-10 19:00:25.064 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.064 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-10 19:00:25.065 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.065 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-10 19:00:25.065 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-10 19:00:25.065 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(2139895366\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into movies (name, id) values (?, ?) 2022-05-10 19:00:25.079 DEBUG 350995 --- [ main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(2139895366\u003copen\u003e)] after transaction Notice that the Creating new transaction with name sequence is present only once this time, meaning we have a single transaction, as we expected. ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:2:1","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"}]