[{"categories":["Spring Framework"],"content":"Introduction In this blog post we are going to explore the internals of Spring’s declarative transaction management. We’ll start with the basics, and then we’ll dive deeper, looking at the internals and some potential pitfalls which we can run into. We’ll be using: Spring Boot 2.6.7 Java 17 Postgresql Spring Data JPA But first, let’s discuss a bit why do we even bother with transactions in the first place? ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:1:0","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Why do we need transactions? The most common reason for using transactions in an application is to maintain a high degree of data integrity and consistency. If we’re unconcerned about the quality of our data, we don’t need to concern ourselves with transactions. Transaction management is ubiquitous, it is present in every Java application which uses a database. The Spring Framework out of the box provides a lot of mechanisms to manage transactions and though it makes our lives easier, it is quite important to understand how it works and what happens under the hood since there are some pitfalls which can lead to undesired results. Let’s take a closer look at what transaction management mechanism Spring provides and how we can use them. Transactions ensure data integrity trough ACID guarantees, which can be recapped as: Atomicity Each transaction is “all or nothing”. All SQL statements in a transaction (select, insert, update, merge or delete) is treated as a single unit. Either all statements are executed, or none of it is executed. Consistency After a transaction, the database is guaranteed to be in a consistent state (all the integrity constraints will be satisfied) Isolation Concurrent transactions don’t interfere with or affect one another. Well, almost. It is possible to have some interference, depending on the used transaction isolation level. Durability Ensures that changes to your data made by successfully executed transactions will be saved, even in the event of system failure Let’s take a look at a practical example. Let’s try to insert into the database the following JPA entity 3 times: @MappedSuperclass public class AbstractEntity { @Id @GenericGenerator(name = \"uuid-generator\", strategy = \"org.hibernate.id.UUIDGenerator\") @GeneratedValue(generator = \"uuid-generator\") protected String id; protected AbstractEntity() { } public String getId() { return id; } public boolean equals(Object other) { if (!(other instanceof AbstractEntity otherEntity)) return false; return Objects.equals(id, otherEntity.getId()); } public int hashCode() { return getClass().hashCode(); } } @Entity @Table(name = \"movies\") public class Movie extends AbstractEntity { private String name; protected Movie() { } private Movie(MovieBuilder builder) { this.name = builder.name; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"Movie{\" + \"name='\" + name + '\\'' + \", id='\" + id + '\\'' + '}'; } public static MovieBuilder builder() { return new MovieBuilder(); } public static class MovieBuilder { private String name; public MovieBuilder name(String name) { this.name = name; return this; } public Movie build() { return new Movie(this); } } } In order to do that, we can create the following Spring Data JPA repository: @Repository public interface MovieRepository extends JpaRepository\u003cMovie, String\u003e { } We can use the MovieRepository presented above and try to insert 3 movies into the database, like shown below: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { List\u003cString\u003e movieNames = List.of( \"Pulp fiction\", \"Joker\", \"Snatch\" ); List\u003cMovie\u003e savedMovies = movieService.saveMovies(movieNames); log.debug(\"Saved movies: {}\", savedMovies); }; } } @Service class MovieService { private final MovieRepository movieRepository; public MovieService(MovieRepository movieRepository) { this.movieRepository = movieRepository; } public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { return movieNames.stream() .map(movieName -\u003e Movie.builder() .name(movieName) .build() ) .map(movieRepository::save) .toList(); } } The question is, how many database transactions are executed by the MovieService.saveMovies() method? The answer is 3, becau","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:2:0","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"How to fix it? To make the MovieService.saveMovies() method atomic and obtain the “all or nothing” behavior, we can just annotate the method with @Transactional annotation. This time the org.springframework.data.jpa.repository.support.SimpleJpaRepository.save() won’t create a new transaction every time it is called but it will notice that with the current thread an active transaction is associated and it will join it. It will look like this: @Service class MovieService { private final MovieRepository movieRepository; public MovieService(MovieRepository movieRepository) { this.movieRepository = movieRepository; } @Transactional public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { return movieNames.stream() .map(movieName -\u003e Movie.builder() .name(movieName) .build() ) .map(movieRepository::save) .toList(); } } If we try to run the example this time, we should see the following in the logs: 2022-05-10 19:00:25.049 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-10 19:00:25.049 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.050 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@376b5cb2] 2022-05-10 19:00:25.056 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Found thread-bound EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.056 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Participating in existing transaction 2022-05-10 19:00:25.064 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Found thread-bound EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.064 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Participating in existing transaction 2022-05-10 19:00:25.065 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Found thread-bound EntityManager [SessionImpl(2139895366\u003copen\u003e)] for JPA transaction 2022-05-10 19:00:25.065 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Participating in existing transaction 2022-05-10 19:00:25.065 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction commit 2022-05-10 19:00:25.065 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Committing JPA transaction on EntityManager [SessionImpl(2139895366\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into movies (name, id) values (?, ?) 2022-05-10 19:00:25.079 DEBUG 350995 --- [main] o.s.orm.jpa.JpaTransactionManager: Closing JPA EntityManager [SessionImpl(2139895366\u003copen\u003e)] after transaction Notice that the Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT sequence is present only once this time, meaning we have a single transaction, as we expected. It’s also interesting that the transaction name has changed. Not it’s inc.evil.spring.tx.management.MovieService.saveMovies which is precisely the fully qualified method name which was annotated with the @Transactional annotation. Also in the logs we can see Participating in existing transaction 3 times, meaning that the org.springframework.data.jpa.repository.support.SimpleJpaRepository.save() method has joined the transaction created by the inc.evil.spring.tx.management.MovieService.saveMovies() method 3 times. Since Spring Data Jpa as a last resort creates transactions for us, during the following examples we are going to use Hibernate’s EntityManager directly because it doesn’t create any transactions and at the same time some of its methods throw exceptions if they’re called without an active","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:2:1","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Types of transaction management The Spring Framework provides us with 2 types of transaction management: Programmatic transaction management With this approach we manually create, commit and roll-back transactions Declarative transaction management With this approach, we just declare that we want a transaction, via an annotation and Spring will take care of the rest Let’s take a look at how both of these approaches look like in practice. ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:0","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Programmatic transaction management As we mentioned, by using the programmatic transaction management approach, we will have to manually create and commit transactions. This is not the preferred approach nowadays, but it does have its use-cases. Before showing any code examples, it’s worth mentioning that when it comes to transaction management (doesn’t matter declarative or programmatic), the entry-point is a spring bean of type PlatformTransactionManager with the name transactionManager. There are different implementations of the PlatformTransactionManager interface, depending on the environment we’re using. Some noteworthy implementations are: org.springframework.orm.jpa.JpaTransactionManager: if we intend to use Hibernate (with or without Spring Data Jpa) org.springframework.jdbc.datasource.DataSourceTransactionManager: if we intend to use sping-jdbc (with the JdbcTemplate) or Springh Data Jdbc org.springframework.transaction.jta.JtaTransactionManager: if we intend to use distributed (or XA) transactions (meaning transactions spanning more than one transactional resource, like a database and a message queue). Although XA transactions look nice, it’s considered a relic of the past and it’s best to be avoided since it has some problems and is not supported by many modern technologies (like Apache Kafka for example). Using the programmatic transaction management involves using directly the PlatformTransactionManager. As we can see below, it’s rather cumbersome to use. The first thing we need to do is to instantiate a DefaultTransactionDefinition which we can use to specify the desired propagation behavior, transaction name, the isolation level, the transaction timeout and the transaction read-only flag. After that by calling the PlatformTransactionManager.getTransaction(TransactionDefinition) method we effectively start the transaction with the desired attributes, execute the unit of work, and then we can try to commit it. If at some point the transaction was marked as rollback-only, it cannot be committed and the only possible outcome is a transaction rollback. @Service class ProgrammaticTxMovieService { private final EntityManager entityManager; private final PlatformTransactionManager transactionManager; public ProgrammaticTxMovieService(EntityManager entityManager, PlatformTransactionManager transactionManager) { this.entityManager = entityManager; this.transactionManager = transactionManager; } public Movie saveMovie(String movieName) { DefaultTransactionDefinition definition = new DefaultTransactionDefinition(); definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); definition.setName(\"saveMovie\"); TransactionStatus transaction = transactionManager.getTransaction(definition); try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); return movie; } catch (Exception e) { transaction.setRollbackOnly(); throw e; } finally { transactionManager.commit(transaction); } } } It’s worth mentioning that injecting the EntityManager directly into a service is kind of an unorthodox approach since services shouldn’t directly talk to the database but should delegate to a DAO instead. The rule was broken for the sake of brevity. A slightly simpler approach is to use the TransactionTemplate class which basically abstracts away the commit and rollback logic. Instead or writing this logic ourselves, we pass a callback. If the callback will not throw any exceptions, the transaction will be committed, otherwise a rollback will happen. @Service class TransactionTemplateProgrammaticTxMovieService { private final EntityManager entityManager; private final PlatformTransactionManager transactionManager; public TransactionTemplateProgrammaticTxMovieService(EntityManager entityManager, PlatformTransactionManager transactionManager) { this.entityManager = entityManager; this.transactionManager = transactionManager; } public Movie saveMovie(String movieName) { DefaultTransactionDefinition def","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:1","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Declarative transaction management With declarative transaction management, we just specify for what methods we want transactional behavior by annotating them with the @Transactional annotation and Spring will take care of the rest. It works something like this: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { List\u003cString\u003e movieNames = List.of( \"Pulp fiction\", \"Joker\", \"Snatch\" ); List\u003cMovie\u003e savedMovies = movieService.saveMovies(movieNames); log.debug(\"Saved movies: {}\", savedMovies); }; } } @Service class MovieService { private final MovieRepository movieRepository; public MovieService(MovieRepository movieRepository) { this.movieRepository = movieRepository; } @Transactional public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { return movieNames.stream() .map(movieName -\u003e Movie.builder() .name(movieName) .build() ) .map(movieRepository::save) .toList(); } } But how exactly does it work? We just annotated a method with an annotation and somehow that method now executes within a transaction. But who starts the transaction? Who commits or rolls-back it? The answer is simple, it’s a proxy! Just as a refresher, the proxy pattern looks like this: We have the Subject interface with the implementation Real Subject. We also have a Proxy which implements the Subject interface, so the proxy looks like a real Subject but it adds additional behavior like caching, logging, security or even transactions. The proxy also has a reference to the real implementation. The client, though unaware of this, will use the Proxy thinking it’s “the real thing”. Let’s try to log the actual class name of the MovieService, and see what’s really going on. @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { log.debug(\"MovieService actual class name: {}\", movieService.getClass().getName()); }; } then, in the logs we will see something like this: 2022-05-11 09:01:10.367 DEBUG 498664 --- [main] SpringDeclarativeTxManagementApplication: MovieService actual class name: inc.evil.spring.tx.management.MovieService$$EnhancerBySpringCGLIB$$38b14d5 We can observe that the actual class name is inc.evil.spring.tx.management.MovieService$$EnhancerBySpringCGLIB$$38b14d5, but in our codebase we have a simple MovieService. Because our MovieService has methods annotated with @Transactional annotation, Spring has created a CGLib proxy for our service and all the logic regarding transaction creation, commit or roll-back is executed precisely by that proxy. So, whenever we have a service which has methods annotated with the @Transactional annotation, Spring will create a proxy for that service and put it in the ApplicationContext. Wherever we want to inject that service, a proxy will be injected instead. The proxy will intercept all the public method calls, check if the method needs a transaction and if so, it will create it and then it will delegate to the original MovieService. After the original method from the MovieService was executed, the proxy will then commit or rollback the transaction, depending on what (if any) exceptions were thrown. As a sequence diagram, the flow looks like this: We can summarize the flow like this: The CommandLineRunner calls MovieService.saveMovies() method. What the CommandLineRunner doesn’t know is that it actually has a reference to a proxy. So in reality the CommandLineRunner is invoking a proxy (a class generated by CGLib in runtime, which looks like a MovieService but it’s a completely different class called MovieService$$EnhancerBySpringCGLIB$$38b14d5) The proxy (the MovieService$$EnhancerBySpringCGLIB$$38b14d5 class) sees that the invoked method (the saveMovies method) is annotated with the @Transactional annotation, so we need a transaction mos","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:2","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional method visibility By default, only public methods can be annotated with the @Transactional annotation. What will happen if we try to make a @Transactional method package-private or protected? Let’s have a look (notice that the MovieService.saveMovie method is package-private): @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); return movie; } } We’ll get a TransactionRequiredException thrown by the EntityManager.persist() method because we don’t have an active transaction (see logs below): 2022-05-12 12:51:40.418 INFO 1079474 --- [main] SpringDeclarativeTxManagementApplication : Started SpringDeclarativeTxManagementApplication in 1.079 seconds (JVM running for 1.355) 2022-05-12 12:51:40.420 INFO 1079474 --- [main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-05-12 12:51:40.428 ERROR 1079474 --- [main] o.s.boot.SpringApplication : Application run failed java.lang.IllegalStateException: Failed to execute CommandLineRunner at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:780) ~[spring-boot-2.6.7.jar:2.6.7] at org.springframework.boot.SpringApplication.callRunners(SpringApplication.java:761) ~[spring-boot-2.6.7.jar:2.6.7] at org.springframework.boot.SpringApplication.run(SpringApplication.java:310) ~[spring-boot-2.6.7.jar:2.6.7] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1312) ~[spring-boot-2.6.7.jar:2.6.7] at org.springframework.boot.SpringApplication.run(SpringApplication.java:1301) ~[spring-boot-2.6.7.jar:2.6.7] at inc.evil.spring.tx.management.SpringDeclarativeTxManagementApplication.main(SpringDeclarativeTxManagementApplication.java:35) ~[classes/:na] Caused by: javax.persistence.TransactionRequiredException: No EntityManager with actual transaction available for current thread - cannot reliably process 'persist' call at org.springframework.orm.jpa.SharedEntityManagerCreator$SharedEntityManagerInvocationHandler.invoke(SharedEntityManagerCreator.java:295) ~[spring-orm-5.3.19.jar:5.3.19] at jdk.proxy2/jdk.proxy2.$Proxy80.persist(Unknown Source) ~[na:na] at inc.evil.spring.tx.management.MovieService.saveMovie(SpringDeclarativeTxManagementApplication.java:162) ~[classes/:na] at inc.evil.spring.tx.management.SpringDeclarativeTxManagementApplication.lambda$commandLineRunner$0(SpringDeclarativeTxManagementApplication.java:41) ~[classes/:na] at org.springframework.boot.SpringApplication.callRunner(SpringApplication.java:777) ~[spring-boot-2.6.7.jar:2.6.7] ... 5 common frames omitted It turns out that we can enable the transactional behavior for package-private and protected methods (private is the exception) by adding a bit of configuration. To do this, we should add in our Java configuration the @EnableTransactionManagement(proxyTargetClass = true) and add in the application context the following spring bean: @Bean public TransactionAttributeSource transactionAttributeSource() { return new AnnotationTransactionAttributeSource(false); } The TransactionAttributeSource constructor has a parameter called publicMethodsOnly (and by default it is set to true) which specifies if only public methods should have the transactional behavior. By setting this flag to false, we obtain transactional behavior for package-private and protected methods as well. Also sin","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:3","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Commit and roll-back rules By default (though this can be configured) the transaction will be committed if: No exceptions were thrown Checked exceptions were thrown In other cases (if unchecked exceptions were thrown, meaning instances or subclasses of RuntimeException), the transaction will be rolled-back. It is surprising that the transaction is committed in case of checked exceptions. The rationale is that checked exceptions are considered business exceptions and we should check the business rules to see if we do need a rollback or not. Let’s try to test it! What do you think will happen when we’ll call the MovieService.saveMovies() method shown below? @Service class MovieService { @Transactional public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { throw new IllegalArgumentException(); } } Since IllegalArgumentException extends RuntimeException, it is considered an unchecked exception and the transaction will be rolled-back. Let’s look at the logs: 2022-05-11 09:22:17.287 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 09:22:17.287 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1159911315\u003copen\u003e)] for JPA transaction 2022-05-11 09:22:17.288 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@37fef327] 2022-05-11 09:22:17.292 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction rollback 2022-05-11 09:22:17.292 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Rolling back JPA transaction on EntityManager [SessionImpl(1159911315\u003copen\u003e)] 2022-05-11 09:22:17.293 DEBUG 505977 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(1159911315\u003copen\u003e)] after transaction 2022-05-11 09:22:17.294 INFO 505977 --- [main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-05-11 09:22:17.303 ERROR 505977 --- [main] o.s.boot.SpringApplication : Application run failed java.lang.IllegalStateException: Failed to execute CommandLineRunner The transaction was indeed rolled-back. Now let’s see what happens if we will use a checked-exception: @Service class MovieService { @Transactional public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) throws IOException { throw new IOException(); } } This time we throw a IOException which extends from Exception which makes it a checked-exception. In this case, even though an exception was thrown out of the @Transactional method, we will have a commit, as seen in the logs below: 2022-05-11 09:26:23.561 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 09:26:23.562 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(347691330\u003copen\u003e)] for JPA transaction 2022-05-11 09:26:23.563 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@775f15fd] 2022-05-11 09:26:23.566 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-11 09:26:23.566 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(347691330\u003copen\u003e)] 2022-05-11 09:26:23.567 DEBUG 507376 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(347691330\u003copen\u003e)] after transaction 2022-05-11 09:26:23.567 INFO 507376 --- [main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To displ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:4","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"How to configure the commit-rollback behavior? It is possible to specify the desired transaction outcome by using the following attributes of the @Transactional annotation: @Transactional(rollbackFor = ...): an array of exception classes for which we want the transaction rolled-back. If we use for example @Transactional(rollbackFor = Exception.class), then we’ll have a rollback if the @Transactional method throws an Exception or any of its subclasses @Transactional(rollbackForClassName = \"...\"): same as above but this time the exception class name is specified as a string. Wildcards are not supported, but we can omit the package and use only the class name, like this: @Transactional(noRollbackForClassName = \"IOException\") or like this @Transactional(noRollbackForClassName = \"java.io.IOException\") it’s the same thing @Transactional(noRollbackFor = ...): an array of exception classes for which we want the transaction committed. @Transactional(noRollbackForClassName = \"...\"): same as above but this time the exception class name is specified as a string. Let’s try to test it. What do you think will happen when we’ll call the MovieService.saveMovies() method shown below? @Service class MovieService { @Transactional(rollbackFor = IOException.class) public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) throws IOException { throw new IOException(); } } The transaction will be rolled-back. Even though a checked-exception was thrown, we specified that we want a rollback in case of an IOException is thrown, and that’s exactly what we’ve got (see the logs below): 2022-05-11 10:02:49.324 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,-java.io.IOException 2022-05-11 10:02:49.324 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(1207093026\u003copen\u003e)] for JPA transaction 2022-05-11 10:02:49.326 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@7608a838] 2022-05-11 10:02:49.330 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction rollback 2022-05-11 10:02:49.330 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Rolling back JPA transaction on EntityManager [SessionImpl(1207093026\u003copen\u003e)] 2022-05-11 10:02:49.331 DEBUG 519567 --- [main] o.s.orm.jpa.JpaTransactionManager: Closing JPA EntityManager [SessionImpl(1207093026\u003copen\u003e)] after transaction Now let’s do the opposite with an unchecked-exception. What do you think will happen when we’ll call the method shown below? @Service class MovieService { @Transactional(noRollbackFor = IllegalArgumentException.class) public List\u003cMovie\u003e saveMovies(List\u003cString\u003e movieNames) { throw new IllegalArgumentException(); } } The transaction will be committed since we’ve specified that we don’t want to rollback in case an IllegalArgumentException exception is thrown (see the logs below): 2022-05-11 10:06:57.206 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovies]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,+java.lang.IllegalArgumentException 2022-05-11 10:06:57.206 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(1692381981\u003copen\u003e)] for JPA transaction 2022-05-11 10:06:57.207 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@2cd3fc29] 2022-05-11 10:06:57.210 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction commit 2022-05-11 10:06:57.211 DEBUG 520985 --- [main] o.s.orm.jpa.JpaTransactionManager: Committing JPA transaction on EntityManager [SessionImpl(1692381981\u003copen\u003e)] 2022-05-11 ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:5","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Is programmatic transaction management equivalent to the declarative one? What if we take a method which uses the declarative transaction management approach and try to rewrite it to use the programmatic approach? Do we get the same behavior? Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) throws IOException { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); offendingMethod(); return movie; } private void offendingMethod() throws IOException { throw new IOException(); } } The method throws an IOException, which is a checked-exception so that means that the transaction will be committed, even though the method thew an exception (see the logs below): 2022-05-12 10:26:06.788 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 10:26:06.788 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(1871084300\u003copen\u003e)] for JPA transaction 2022-05-12 10:26:06.790 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@be6d228] 2022-05-12 10:26:06.797 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction commit 2022-05-12 10:26:06.798 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager: Committing JPA transaction on EntityManager [SessionImpl(1871084300\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-12 10:26:06.810 DEBUG 1024681 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(1871084300\u003copen\u003e)] after transaction 2022-05-12 10:26:06.811 INFO 1024681 --- [main] ConditionEvaluationReportLoggingListener : Error starting ApplicationContext. To display the conditions report re-run your application with 'debug' enabled. 2022-05-12 10:26:06.819 ERROR 1024681 --- [main] o.s.boot.SpringApplication : Application run failed java.lang.IllegalStateException: Failed to execute CommandLineRunner Now let’s rewrite the method to use the programmatic transaction management approach using the TransactionTemplate, as shown below: @Service @Slf4j class MovieService { private final EntityManager entityManager; private final PlatformTransactionManager transactionManager; public MovieService(EntityManager entityManager, PlatformTransactionManager transactionManager) { this.entityManager = entityManager; this.transactionManager = transactionManager; } public Movie saveMovie(String movieName) throws IOException { DefaultTransactionDefinition definition = new DefaultTransactionDefinition(); definition.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED); definition.setName(\"saveMovie\"); TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager, definition); return transactionTemplate.execute(status -\u003e { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); offendingMethod(); //does not compile return movie; }); } private void offendingMethod() throws IOException { throw new IOException(); } } Well, the code above does not compile since the TransactionTemplate.execute(TransactionCallback callback) method have a parameter of type TransactionCallback, which is a functional interface which d","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:3:6","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Transaction propagation What will happen if we’ll call one @Transactional method from another? Will we have 2 transactions or just one? Let’s run the example below and look at the logs. We have 2 services: MovieService and MovieServiceTwo. First we call the transactional MovieService.saveMovie() method and then it tries to invoke the MovieServiceTwo.save() which is also transactional. @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final MovieServiceTwo movieServiceTwo; public MovieService(MovieServiceTwo movieServiceTwo) { this.movieServiceTwo = movieServiceTwo; } @Transactional public Movie saveMovie(String movieName) { log.debug(\"Inside MovieService\"); Movie movie = Movie.builder() .name(movieName) .build(); return movieServiceTwo.save(movie); } } @Service @Slf4j class MovieServiceTwo { private final EntityManager entityManager; public MovieServiceTwo(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional public Movie save(Movie movie) { log.debug(\"Inside MovieServiceTwo\"); entityManager.persist(movie); return movie; } } If we look at the logs, we can see that we have a single transaction: 2022-05-11 15:34:42.455 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 15:34:42.455 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(2020226167\u003copen\u003e)] for JPA transaction 2022-05-11 15:34:42.457 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@46b6701e] 2022-05-11 15:34:42.460 DEBUG 690207 --- [main] i.e.s.tx.management.MovieService : Inside MovieService 2022-05-11 15:34:42.460 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(2020226167\u003copen\u003e)] for JPA transaction 2022-05-11 15:34:42.460 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-11 15:34:42.463 DEBUG 690207 --- [main] i.e.s.tx.management.MovieServiceTwo : Inside MovieServiceTwo 2022-05-11 15:34:42.468 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-11 15:34:42.468 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(2020226167\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-11 15:34:42.481 DEBUG 690207 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(2020226167\u003copen\u003e)] after transaction What happened is that the proxy for MovieServiceTwo has found an existing transaction for the current thread and it joined it. Basically transactions are like a viral disease, they can infect other methods. The @Transactional annotation has an attribute called propagation and it specifies the desired behavior when a transactional method is called with or without an active transaction. Here are the possible propagation levels: @Transactional(propagation = Propagation.REQUIRED): the default. Starts a transaction if we don’t have one, otherwise join the existing one @Transactional(propagation = Propagation.REQUIRES_NEW): Starts a transaction if we don’t have one, otherwise suspend the existing one and create a new one @Transactional(propagation = Propagation.SUPPORTS): Join the existing transaction. If we don’t have a transaction execute without it @Transactional(propagation = Propagation.MANDATORY): Join the existing transaction","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:0","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.REQUIRED) When calling a method annotated with @Transactional(propagation = Propagation.REQUIRED), if the current thread is not associated with a transaction, a new transaction will be created. If a transaction exists, the method will just join it. But what will happen if one @Transactional method calls another @Transactional method from a different service, with propagation = Propagation.REQUIRED and the second service throws an exception? Do we lose all the work done by the first service as well or only the work done by the second service? Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } catch (Exception e) { log.error(\"Caught an exception\"); return null; } } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); throw new NullPointerException(); } } If we look at the logs, we can see that the ActorService.saveActor() method has joined the existing transaction (the Participating in existing transaction) and because it threw an exception, the transaction was marked as rollback-only by the proxy. Because the transaction was marked as rollback-only, it cannot be committed, even though it tried to (see Initiating transaction commit in the logs). Also we can notice that trying to catch the exception didn’t help at all, since the exception “passed though” the proxy and because of that , it has set the rollback-only flag. We can also observe that all of the database work done by both services was lost (or rolled-back) since we don’t have any SQL statements logged (we’ve configured Hibernate to do so). 2022-05-11 17:02:05.767 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 17:02:05.767 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1478683866\u003copen\u003e)] for JPA transaction 2022-05-11 17:02:05.769 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@3ee6dc82] 2022-05-11 17:02:05.777 DEBUG 716638 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-11 17:02:05.778 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1478683866\u003copen\u003e)] for JPA transaction 2022-05-11 17:02:05.778 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-11 17:02:05.781 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating transaction failed - marking existing transaction as rollback-only 2022-05-11 17:02:05.781 DEBUG 716638 --- [main] o.s.orm.jpa.JpaTransactionManager : Setting JPA transaction on EntityManager [SessionImpl(1","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:1","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.REQUIRES_NEW) When calling a method annotated with @Transactional(propagation = Propagation.REQUIRES_NEW), if the current thread is not associated with a transaction, a new transaction will be created. If a transaction exists, the existing transaction will be suspended and we’ll create a new one, execute it and then finally we’ll resume the initial one. But what will happen if one @Transactional method calls another @Transactional(propagation = Propagation.REQUIRES_NEW) method from a different service, and the second service throws an exception? In this case we have 2 transactions and we expect a rollback only for the second transaction. Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } catch (Exception e) { log.error(\"Caught an exception\"); return null; } } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRES_NEW) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); throw new NullPointerException(); } } Looking at the logs we can observe that when the ActorService.saveActor() method is called, the existing transaction is indeed suspended (Suspending current transaction, creating new transaction with name [inc.evil.spring.tx.management.ActorService.saveActor]). When the ActorService.saveActor() throws an exception, the new transaction is rollbacked (Rolling back JPA transaction on EntityManager [SessionImpl(1959219756\u003copen\u003e)]) and then the initial transaction is resumed (Resuming suspended transaction after completion of inner transaction). Since the MovieService.saveMovie() catches the exception thrown by the ActorService.saveActor(), no exceptions will “pass though” the proxy of the MovieService class and that means that the initial transaction will be committed (see the logs below). If we were to remove the try-catch block from the MovieService.saveMovie() method, both transactions will be rolled-back. We can also observe that the work done by the MovieService.saveMovie() is preserved, we have an insert SQL statement in the logs. 2022-05-11 17:19:29.308 DEBUG 721804 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 17:19:29.308 DEBUG 721804 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1598068850\u003copen\u003e)] for JPA transaction 2022-05-11 17:19:29.310 DEBUG 721804 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@506aa618] 2022-05-11 17:19:29.318 DEBUG 721804 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-11 17:19:29.318 DEBUG 721804 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1598068850\u003copen\u003e)] for JPA transaction 2022-05-11 17:19:29.319 DEBUG 7218","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:2","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.NESTED) The propagation = Propagation.NESTED works pretty much the same way as propagation = Propagation.REQUIRES_NEW, if the current thread is not associated with a transaction, a new transaction will be created. If a transaction exists, we’ll create a JDBC Savepoint before entering the new transactional method and in case of failure we will rollback to the jdbc savepoint. Basically if one @Transactional method calls another @Transactional(propagation = Propagation.NESTED) method from a different service, and the second service throws an exception, we will rollback to the jdbc savepoint and in this way we’ll preserve the work done by the first service. Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } catch (Exception e) { log.error(\"Caught an exception\"); return null; } } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.NESTED) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); throw new NullPointerException(); } } 2022-05-11 17:43:55.526 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-11 17:43:55.527 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(711964207\u003copen\u003e)] for JPA transaction 2022-05-11 17:43:55.528 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@7e2bd5e6] 2022-05-11 17:43:55.536 DEBUG 729067 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-11 17:43:55.537 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(711964207\u003copen\u003e)] for JPA transaction 2022-05-11 17:43:55.537 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating nested transaction with name [inc.evil.spring.tx.management.ActorService.saveActor] 2022-05-11 17:43:55.537 ERROR 729067 --- [main] i.e.s.tx.management.MovieService: Caught an exception 2022-05-11 17:43:55.537 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-11 17:43:55.537 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(711964207\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-11 17:43:55.545 DEBUG 729067 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(711964207\u003copen\u003e)] after transaction Looking at the logs we can see that only the work done by the MovieService.saveMovie() method was successfully inserted into the database. ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:3","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.SUPPORTS) This is an easy one, it works as if the @Transactional annotation is not present. If we have an active transaction, we join it. If we don’t, execute without a transaction. Let’s take a look at the example below: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { try { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } catch (Exception e) { log.error(\"Caught an exception\"); return null; } } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.SUPPORTS) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); return actor; } } We can see that the ActorService.saveActor which has @Transactional(propagation = Propagation.SUPPORTS) has joined the existing transaction, but if the @Transactional annotation wasn’t present, the same thing would happen. 2022-05-12 10:01:38.812 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 10:01:38.812 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1185631996\u003copen\u003e)] for JPA transaction 2022-05-12 10:01:38.814 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@40016ce1] 2022-05-12 10:01:38.822 DEBUG 1017539 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-12 10:01:38.822 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1185631996\u003copen\u003e)] for JPA transaction 2022-05-12 10:01:38.822 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-12 10:01:38.824 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-12 10:01:38.824 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(1185631996\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into actors (name, id) values (?, ?) 2022-05-12 10:01:38.832 DEBUG 1017539 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(1185631996\u003copen\u003e)] after transaction What will happen if both methods have the @Transactional(propagation = Propagation.SUPPORTS) annotation? Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManage","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:4","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.NOT_SUPPORTED) The @Transactional(propagation = Propagation.NOT_SUPPORTED) propagation works in the following way: if we don’t have a transaction, no problem, execute without it. If we do have one, suspend it, execute the method with the propagation = Propagation.NOT_SUPPORTED and then resume the transaction. Basically it is useful when we want to call a method from a different service which doesn’t need a transaction and at the same time we want to prevent that method from marking the transaction as rollback-only in case of exceptions. Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); try { actorService.saveActor(\"John Travolta\"); } catch (Exception e) { log.error(\"Caught an exception\"); } return movie; } } @Service @Slf4j class ActorService { @Transactional(propagation = Propagation.NOT_SUPPORTED) public Actor saveActor(String name) { throw new RuntimeException(); } } If we analyze the logs we can see that the ActorService.saveActor() suspends the transaction (Suspending current transaction) and then it resumes it (Resuming suspended transaction after completion of inner transaction). Even though the ActorService.saveActor() threw a RuntimeException which triggers a rollback usually, we successfully committed the transaction since the exception was thrown when the transaction was suspended (see logs below): 2022-05-12 11:18:46.933 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 11:18:46.933 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1421763091\u003copen\u003e)] for JPA transaction 2022-05-12 11:18:46.936 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@7eee6c13] 2022-05-12 11:18:46.947 DEBUG 1040575 --- [main] i.e.s.tx.management.MovieService: Calling ActorService 2022-05-12 11:18:46.948 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1421763091\u003copen\u003e)] for JPA transaction 2022-05-12 11:18:46.948 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Suspending current transaction 2022-05-12 11:18:46.951 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Should roll back transaction but cannot - no transaction available 2022-05-12 11:18:46.951 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Resuming suspended transaction after completion of inner transaction 2022-05-12 11:18:46.951 ERROR 1040575 --- [main] i.e.s.tx.management.MovieService: Caught an exception 2022-05-12 11:18:46.951 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-12 11:18:46.951 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(1421763091\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-12 11:18:46.964 DEBUG 1040575 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityMana","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:5","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.NEVER) This transaction propagation level does not support transactions. If we’ll call a method annotated with @Transactional(propagation = Propagation.NEVER) without a transaction, everything will work fine. If we do have a transaction, we’ll get an exception since the method doesn’t support transactions. This propagation level is useful for scenarios where we have a method which doesn’t need a transaction and we want to prevent others from calling the method when there’s an active transaction. It is considered that transactions should be as small as possible and we can use this propagation level to prevent a long-running method being called from a transaction, since that will increase significantly the transaction lifespan. Let’s have a look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.NEVER) public Movie saveMovie(String movieName) { return Movie.builder() .name(movieName) .build(); } } If we look at the logs, we can see that no transaction was created: 2022-05-12 11:41:01.254 INFO 1047157 --- [main] SpringDeclarativeTxManagementApplication : Started SpringDeclarativeTxManagementApplication in 1.045 seconds (JVM running for 1.338) 2022-05-12 11:41:01.260 INFO 1047157 --- [ionShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' Let’s try out a different example. What will happen if we call a @Transactional(propagation = Propagation.NEVER) with an active transaction, like shown below? @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } } @Service @Slf4j class ActorService { @Transactional(propagation = Propagation.NEVER) public Actor saveActor(String name) { return Actor.builder() .name(name) .build(); } } In this case a IllegalTransactionStateException will be thrown since the ActorService.saveActor() method does not support transactions (see logs below): 2022-05-12 11:43:01.090 DEBUG 1047930 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 11:43:01.090 DEBUG 1047930 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(711964207\u003copen\u003e)] for JPA transaction 2022-05-12 11:43:01.091 DEBUG 1047930 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@7e2bd5e6] 2022-05-12 11:43:01.100 DEBUG 1047930 --- [main] i.e.s.tx.man","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:6","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"@Transactional(propagation = Propagation.MANDATORY) The @Transactional(propagation = Propagation.MANDATORY) is the opposite of Propagation.NEVER. In order to call a method with the @Transactional(propagation = Propagation.MANDATORY) we need to have an active transaction, otherwise we’ll get an exception. Let’s have a closer look: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED) public Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); log.debug(\"Calling ActorService\"); actorService.saveActor(\"John Travolta\"); return movie; } } @Service @Slf4j class ActorService { private final EntityManager entityManager; public ActorService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(propagation = Propagation.MANDATORY) public Actor saveActor(String name) { Actor actor = Actor.builder() .name(name) .build(); entityManager.persist(actor); return actor; } } We can see from the logs that everything worked fine, we have a single transaction (started by MovieService.saveMovie()) and the ActorService.saveActor() has joined it: 2022-05-12 11:52:22.465 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-12 11:52:22.465 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(1186328673\u003copen\u003e)] for JPA transaction 2022-05-12 11:52:22.466 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@376af784] 2022-05-12 11:52:22.475 DEBUG 1050965 --- [main] i.e.s.tx.management.MovieService : Calling ActorService 2022-05-12 11:52:22.475 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(1186328673\u003copen\u003e)] for JPA transaction 2022-05-12 11:52:22.475 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-12 11:52:22.477 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-12 11:52:22.478 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(1186328673\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) Hibernate: insert into actors (name, id) values (?, ?) 2022-05-12 11:52:22.491 DEBUG 1050965 --- [main] o.s.orm.jpa.JpaTransactionManager : Closing JPA EntityManager [SessionImpl(1186328673\u003copen\u003e)] after transaction 2022-05-12 11:52:22.494 INFO 1050965 --- [ionShutdownHook] j.LocalContainerEntityManagerFactoryBean : Closing JPA EntityManagerFactory for persistence unit 'default' 2022-05-12 11:52:22.495 INFO 1050965 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown initiated... 2022-05-12 11:52:22.497 INFO 1050965 --- [ionShutdownHook] com.zaxxer.hikari.HikariDataSource : HikariPool-1 - Shutdown completed. Process finished with exit code 0 If we try to call a method annotated with @Transactional(propagation = Propagation.MANDATORY) without a transaction, we’ll get an exception: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:4:7","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Transaction timeouts The @Transactional annotation has an attribute called timeout which specifies the transaction timeout in seconds. If the transaction won’t be committed in the given number of seconds, it will be automatically rolled-back. The timeout attribute along with propagation = Propagation.REQUIRED sometimes has interesting behavior. When a method with propagation = Propagation.REQUIRED is joining an existing transaction, it inherits the transaction attributes like isolation, readOnly and timeout from the existing transaction. This could lead to unexpected results sometimes. Let’s look at an example. The MovieService.saveMovie() method is the one starting the transaction and it declares the transaction timeout as one second. The ActorService.saveActor() method will join the existing transaction, but it wants a timeout of 10 seconds. Also the ActorService.saveActor() has an artificial delay of 2 seconds. In this case, what do you think will happen? @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final ActorService actorService; private final EntityManager entityManager; public MovieService(ActorService actorService, EntityManager entityManager) { this.actorService = actorService; this.entityManager = entityManager; } @Transactional(propagation = Propagation.REQUIRED, timeout = 1) public Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); actorService.saveActor(\"John Travolta\"); return movie; } } @Service @Slf4j class ActorService { @Transactional(propagation = Propagation.REQUIRED, timeout = 10) public Actor saveActor(String name) { try { TimeUnit.SECONDS.sleep(2); return null; } catch (InterruptedException e) { return null; } } } Well, if we look at the logs we can see that the transaction timed-out and was rolled-back, which basically means that ActorService.saveActor() method has inherited the timeout attribute from the existing transaction it has joined. The transaction was rolled-back since the transaction timeout was one second but the ActorService.saveActor() method executed for 2 seconds. 2022-05-12 15:18:16.374 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Creating new transaction with name [inc.evil.spring.tx.management.MovieService.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,timeout_1 2022-05-12 15:18:16.374 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Opened new EntityManager [SessionImpl(337295973\u003copen\u003e)] for JPA transaction 2022-05-12 15:18:16.376 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@d504137] 2022-05-12 15:18:16.384 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Found thread-bound EntityManager [SessionImpl(337295973\u003copen\u003e)] for JPA transaction 2022-05-12 15:18:16.385 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Participating in existing transaction 2022-05-12 15:18:18.391 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit 2022-05-12 15:18:18.392 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Committing JPA transaction on EntityManager [SessionImpl(337295973\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-12 15:18:18.405 DEBUG 1135044 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction rollback after commit exception org.springframework.orm.jpa.JpaSystemException: transaction timeout expired; nested exception is org.hibernate.TransactionException: transaction timeout expired at org.springframework.o","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:5:0","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Read-only transactions When using the JpaTransactionManager (configured by default when using spring-data-jpa), every transaction which is created also creates an EntityManager which represents the so-called “unit of work” in Hibernate. Though the EntityManager is not thread-safe, it’s not a problem since transactions are thread-local (or bound to a specific thread). We can easily verify that when creating a new transaction an EntityManager is created as well by looking at the following example: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.saveMovie(\"Pulp fiction\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieServiceOne(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional protected Movie saveMovie(String movieName) { Movie movie = Movie.builder() .name(movieName) .build(); entityManager.persist(movie); return movie; } } In the logs we can observe the sequence: Opened new EntityManager [SessionImpl(1982072255\u003copen\u003e)] for JPA transaction and Closing JPA EntityManager [SessionImpl(1982072255\u003copen\u003e)] after transaction. 2022-05-13 08:42:02.640 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieServiceOne.saveMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT 2022-05-13 08:42:02.641 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(1982072255\u003copen\u003e)] for JPA transaction 2022-05-13 08:42:02.642 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@37a67cf] 2022-05-13 08:42:02.652 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Initiating transaction commit 2022-05-13 08:42:02.653 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Committing JPA transaction on EntityManager [SessionImpl(1982072255\u003copen\u003e)] Hibernate: insert into movies (name, id) values (?, ?) 2022-05-13 08:42:02.665 DEBUG 1250340 --- [main] o.s.orm.jpa.JpaTransactionManager: Closing JPA EntityManager [SessionImpl(1982072255\u003copen\u003e)] after transaction It is known that the EntityManager acts as a first-level cache (in different sources there’s different nomenclature for this, sometimes this is called that the EntityManager has a persistence context or that the EntityManager represents the persistence context), which basically is a cache for entities in the persistent state. The question which arrives at this point is: when a transactional method from one service joins an existing transaction (created by another service), is the EntityManager reused? Let’s have a look at an example: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieServiceOne movieService) { return args -\u003e { movieService.findMovie(\"aa3e4567-e89b-12d3-b457-5267141750aa\"); }; } } @Service @Slf4j class MovieServiceOne { private final EntityManager entityManager; private final MovieServiceTwo movieServiceTwo; public MovieServiceOne(EntityManager entityManager, MovieServiceTwo movieServiceTwo) { this.entityManager = entityManager; this.movieServiceTwo = movieServiceTwo; } @Transactional protected Movie findMovie(String id) { Movie movie = entityManager.find(Movie.class, id); log.debug(\"Found movie: {}\", movie); movieServiceTwo.findMovie(id); return movie; } } @Service @Slf4j class MovieServiceTwo { private final EntityManager entityManager; public MovieServiceTwo(EntityManager entityManager) { t","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:6:0","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"The readOnly attribute We can mark the transaction as being read-only by specifying the readOnly attribute, like this: @Transactional(readOnly = true). Read-only transactions are considered to be more performant and another effect of this attribute is that Hibernate's dirty-checking mechanisms would be disabled. When fetching an entity, Hibernate apart from the fact that it maps the ResultSet to a Java object, it creates a snapshot of the ResultSet so that it can use it later, at flush-time to determine if the entity is dirty (meaning we need to update the entity). With read-only transactions, this actions doesn’t take place and this is precisely the reason of performance improvement. Let’s check it. Take a look at the example below: @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.findMovie(\"aa3e4567-e89b-12d3-b457-5267141750aa\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(readOnly = true) protected Movie findMovie(String id) { Movie movie = entityManager.find(Movie.class, id); log.debug(\"Found movie: {}\", movie); movie.setName(movie.getName() + \"!\"); return movie; } } In the example above, in a read-only transaction we fetch a Movie entity and change its name (making the entity dirty). If we had a regular “write” transaction, this will trigger an SQL update on the movie table. Let’s check the logs to see what happened in our case: 2022-05-13 19:22:55.713 DEBUG 1353141 --- [main] o.s.orm.jpa.JpaTransactionManager: Creating new transaction with name [inc.evil.spring.tx.management.MovieService.findMovie]: PROPAGATION_REQUIRED,ISOLATION_DEFAULT,readOnly 2022-05-13 19:22:55.713 DEBUG 1353141 --- [main] o.s.orm.jpa.JpaTransactionManager: Opened new EntityManager [SessionImpl(196161345\u003copen\u003e)] for JPA transaction 2022-05-13 19:22:55.715 DEBUG 1353141 --- [main] o.s.orm.jpa.JpaTransactionManager: Exposing JPA transaction as JDBC [org.springframework.orm.jpa.vendor.HibernateJpaDialect$HibernateConnectionHandle@75dd0f94] Hibernate: select movie0_.id as id1_1_0_, movie0_.name as name2_1_0_ from movies movie0_ where movie0_.id=? 2022-05-13 19:22:55.724 DEBUG 1353141 --- [main] i.e.s.tx.management.MovieService : Found movie: Movie{name='Pulp Fiction!', id='aa3e4567-e89b-12d3-b457-5267141750aa'} 2022-05-13 19:22:55.725 DEBUG 1353141 --- [main] o.s.orm.jpa.JpaTransactionManager : Initiating transaction commit No SQL updates spotted, signifying that the dirty-checking mechanism was indeed disabled. Good idea If the transaction only reads data, mark it as read-only. This wil not only improve the performance, but also serve as a form of documentation. Now, what will happen if in a readOnly transaction we’ll try to persist an entity, as shown in the example below? @Slf4j @SpringBootApplication public class SpringDeclarativeTxManagementApplication { public static void main(String[] args) { SpringApplication.run(SpringDeclarativeTxManagementApplication.class, args); } @Bean public CommandLineRunner commandLineRunner(MovieService movieService) { return args -\u003e { movieService.findMovie(\"aa3e4567-e89b-12d3-b457-5267141750aa\"); }; } } @Service @Slf4j class MovieService { private final EntityManager entityManager; public MovieService(EntityManager entityManager) { this.entityManager = entityManager; } @Transactional(readOnly = true) protected Movie findMovie(String id) { Movie movie = entityManager.find(Movie.class, id); log.debug(\"Found movie: {}\", movie); Movie newMovie = Movie.builder() .name(\"Joker\") .build(); entityManager.persist(newMovie); return movie; } } Well, the EntityManager.persist() will be silently ignored (without throwing any e","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:6:1","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":["Spring Framework"],"content":"Conclusion In this blog post we made a gentle introduction on Spring's declarative and programmatic transaction management approaches, looked at all the propagation levels, what’s the default commit and rollback behavior (and how to configure it), discussed that by default only public methods can be transactional, but with a bit of configuration we can enable the transactional behavior for package-private and protected methods as well. We also compared a bit the programmatic and declarative approaches and saw that they aren’t 100% equivalent, and we also saw that read-only transactions disable the dirty-checking mechanism. We’ll dive deeper in another blog post where we’ll look at some puzzlers and limitations of declarative transaction management. ","date":"2022-05-10","objectID":"/posts/introduction_to_declarative_tx_management/:7:0","tags":["Spring Framework","Transaction management"],"title":"Introduction to declarative transaction management in Spring Framework","uri":"/posts/introduction_to_declarative_tx_management/"},{"categories":null,"content":"I have about 5 years of experience in development using the Java programming language. I’m very passionate and driven by a desire to learn as much as possible about the Java platform and its ecosystem, (Spring Boot, Hibernate, AWS, Apache Kafka, Debezium and many more) and to implement high-quality solutions using industry best practices. ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About me","uri":"/about/"}]